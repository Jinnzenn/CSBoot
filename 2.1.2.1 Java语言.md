# 2.1.2.1 Java语言

学习编程语言：写出符合合法的语句（合法：语法正确）



学习程序设计：设计出可靠、鲁棒、健壮的程序

？





学习软件工程：多程序协作

？

## 设计思想：
（具体看2.3.1 面向对象编程Object-oriented Programme（Java））

## 使用规范：
Java语言规范
Java Language Specification
具体依赖不同版本的实现

### 简介
introduction

### 语法
Grammars

### 词汇结构
Lexical Structure

- 内存编码集
Unicode

	- 将数据存储到文件时，需要将数据先编码为其他编码集

- 词汇翻译
Lexical Translations
- 内存编码集转义
Unicode Escape

	- 将unicode内存编码值直接存储

- 行终止符
Line Terminators
- 输入元素和标记
Input Elements and Tokens
- 空格
Whitespace
- 注释
Comments
- 标识符
Identifiers
- 关键字/保留字
Keywords

	- 关键字是特定的字符序列 character sequence
		- final关键字
使用总结

			- final关键字主要用在三个地方：变量、方法、类。
1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。
在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final

	- restricted   keywords: 

- 字面量
Literals

	- true、false
	- null

- 分隔符
Separators
- 操作符
Operators

### 类型、值和变量
Types, Values, and Variables

### 类型转换和上下文环境
Conversions and Contexts

### 名称
Names

- 名称空间

### 包和模组
Packages and Modules

### 类
Classes

### 接口
Interfaces

### 数组
Arrays

### 异常
Exception

### 执行
Execution

### 二进制兼容性
Binary Compatibility

### 语句和语句块
Blocks and Statements

### 表达式
Expresstions

### 确定性赋值
Definite Assignment

### 线程和锁
Threads and Locks

### 类型推断
Type inference

## 规范实现：
JDK源码剖析

### Java API规范根据应用场景切分出的不同技术体系

- JavaSE APIs

	- 它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。

- JavaEE APIs

	- 企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序，是支持大型开发项目的 Java 类库的扩展版本。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。

- JavaME APIs

	- Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。

### Java SE Development Kit

它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。

- 语言
Java Language
- 开发工具和工具接口
Tools & Tool APIs

	- 编译器
javac.exe
	- 调试器
jdb.exe
	- 剖析工具
javaprof.exe
	- 文件反编译工具
javap.exe
	- 文档生成工具
javadoc.exe
	- Jar包生成工具
jar.exe
	- 控制台工具
JConsole.exe
	- 远程方法调用（工具接口）
RMI(Remote Method Invocation)
	- 数据库（工具接口）
Java DB
	- 其他开发工具和工具接口

- Java Runtime Environment (JRE)

  java 运行时环境JRE
  它是运行已编译 Java 程序所需的所有内容的集合，，是 JVM 的实施实现，提供了运行 java 程序的平台。包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，但是不包含 java 编译器 / 调试器之类的开发工具，它不能用于创建新程序。

	- Java Virtual Machine (JVM)

	  java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。
	  注意区分JVM规范和虚拟机的具体实现，比如JVM对内存区域划分了方法区，而HotSpot虚拟机将方法区具体实现为永久区。
	  
	  参考资料：
	  《深入理解JVM虚拟机》

	- 基础支持构件

		- 部署构件
Deployment

			- Java Web Starter
			- Applet/Java Plug-in

		- 用户界面工具包
User Interface Toolkits

			- JavaFX
			- Swing
			- AWT
			- 其他部分

	- Libraries
Java类库

		- 常用系统基础包
java.base package

			- [P] java.lang.* 
（提供语言特性）

				- [P] java.lang
(提供基本的编程支持）

				  提供java语言程序设计的基础类(基础数据类型的封装类、Class、math、线程类)。lang包中的类的应用不需要手动import。

					- 类型部分

						- 对象基类

							- [C] java.lang.Object
要点：
clone()(只有实现Cloneable接口才可调用)，equals()默认是比较两个对象的地址，可override

							  public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了
							  final关键字修饰，故不允许子类重写。
							  public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的
							  HashMap。
							  public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用
							  户比较字符串的值是否相等。
							  protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返
							  回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，
							  x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone
							  方法并且进行调用的话会发生CloneNotSupportedException异常。
							  public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个
							  方法。
							  public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监
							  视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
							  public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤
							  醒在此对象监视器上等待的所有线程，而不是一个线程。
							  public final native void wait(long timeout) throws InterruptedException//native方法，并且不
							  能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。
							  public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参
							  数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。
							  public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直
							  等待，没有超时时间这个概念
							  protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作

						- 类型信息

							- [C] java.lang.Class
							- [C] java.lang.ClassLoader
							- [C] java.lang.Complier

						- 无数据

							- [C] java.lang.void

						- 数据类型的封装

							- [C] java.lang.Boolean
							- [C] java.lang.Character
							- 基础类型的装箱/拆箱

								- [C] java.lang.Byte
								- [C] java.lang.Short
								- [C] java.lang.Integer
								- [C] java.lang.Long
								- [C] java.lang.Float
								- [C] java.lang.Double

						- 字符串/字符序列

							- [C] java.lang.String
要点：实现原理是使用 final 关键字字符数组保存字符串:
//private final char value[];
因此，每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。
适合操作少量数据时使用。

							  //String的用法：
							  //java中String是只读的，没有办法进行变换，因此需要使用StringBuilder。
							  String.length() //获取字符串的长度
							  String.charAt(i) //获取第i个字符的内容
							  String.subString(start)  //获取[start,）的字符串
							  String.subString(start,end) //获取[start,end）中的字符串
							  char[] c = iniString.toCharArray() //将字符串转为char数组来进行改变字符内容
							  String.equal() //判断两个字符串是否相等 @override

							- [C] AbstractStringBuilder
要点：使用字符数组保存字符串 char[]value , 没有用 final 关键字修饰

							  abstract class AbstractStringBuilder implements Appendable, CharSequence {
							  char[] value;
							  int count;
							  AbstractStringBuilder() {
							  } 
							  AbstractStringBuilder(int capacity) {
							  value = new char[capacity];
							  }

								- [C] java.lang.StringBuilder
没有对方法增加同步锁，线程不安全。相同情况下使用StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。
适合单线程操作字符串缓冲区下操作大量数据

								  //StringBuilder的用法：
								  new String(stringBuilder);//用stringBuilder来初始化String
								  除了String中支持的方法外，StringBuilder支持字符的增、删、改。
								  stringBuilder.append("we"); //添加we在词尾
								  stringBuilder.insert(0,"we");//在0的位置加入后面的内容
								  stringBuilder.delete(0,1); //删除[0,1)的数据
								  stringBuilder.deleteCharAt(0);
								  stringBuilder.setCharAt(0,'p'); //在某一个独特位置设置字符
								  char c = stringBuilder.charAt(i);//查询某个位置上的字符
								  System.out.println(stringBuilder);
								  其他：
								  expandCapacity()、append()、insert()、indexOf()

								- [C] java.lang.StringBuffer
对方法增加同步锁，线程安全类
适合多线程操作字符串缓冲区下操作大量数据

						- [C] java.lang.Enum
枚举
						- [C] java.lang.Package
包
						- [C] java.lang.Iterable
迭代器
						- [C] java.lang.Comparable
比较器

					- 工具部分

						- 数学

							- [C] java.lang.math

						- 安全

							- [C] java.lang.SecurityManager

						- 注解

							- [C] java.lang.Override

					- 系统部分

						- 进程

							- [C] java.lang.Process

						- 线程

							- [C] java.lang.Thread

						- 运行

							- [C] java.lang.System
输入输出流、错误流的父类

							  1)三个对象:InputStream in;//标准输入流PrintStream out;//标准输出流PrintStream err;//标准错误流。如System.out.println();
							  2)常用方法:arraycopy(被复制数组,起始位置，复制到的数组，起始位置，复制长度);数组复制;
							  currentTimeMillis()和Date类中getTime方法完全是一样的;
							  gc()垃圾，回收不许要手动调用;

							- [C] java.lang.Runnable
							- [C] java.lang.RunTime

						- 堆栈

							- [C] java.lang.StackTraceElement

						- 异常

							- [C] java.lang.Throwable
要点：可以使用public string getMessage()返回异常发生时的详细信息

							  public string getMessage():返回异常发生时的详细信息
							  public string toString():返回异常发生时的简要描述
							  public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可
							  以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同
							  public void printStackTrace():在控制台上打印Throwable对象封装的异常信息

								- [C] java.lang.Error
程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无
关，而表示代码运行时 JVM（Java 虚拟机）出现的问题，比如内存溢出。

									- VirtulMachineError

										- StackoverflowError
										- OutOfMemoryError

									- AWTError

								- [C] java.lang.Exception
程序本身可以处理的异常。

									- 已检查异常，这是编码时非常常用的，所有checked exception都是需要在代码中处理的。它们的发生是可以预测的，正常的一种情况，可以合理的处理。比如IOException，或者一些自定义的异常。除了RuntimeException及其子类以外，都是checked exception。

										- EOFException：文件已结束异常。
										- SQLException：提供关于数据库访问错误或其他错误信息的异常。
										- NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。
										- IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。
										- NoSuchMethodException：无法找到某一特定方法时，抛出该异常。
										- UnsupportedOperationException：当不支持请求的操作时，抛出该异常。
										- FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。

									- [C] java.lang.Exception.RuntimeException
未检查异常 ，Java 虚拟机正常运行期间抛出的异常的超类。
RuntimeException及其子类都是unchecked exception。比如NPE空指针异常，除数为0的算数异常ArithmeticException等等，这种异常是运行时发生，无法预先捕捉处理的。Error也是unchecked exception，也是无法预先处理的。

										- NullPointerException：当应用程序试图访问空对象时，则抛出该异常。
										- ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 
										- IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 

											- ArrayOutOfBoundsException：数组索引越界异常。

										- ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。
										- NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。
										- ClassNotFoundException：类文件路径不存在时，抛出此异常。
										- ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。
										- SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。
										- 等等

				- [P] java.lang.annotation
（强化注解）
				- [P] java.lang.reflect
（支持反射机制）
				- 其他部分等等

			- [P] java.util.*
（提供程序设计的工具设施）

				- [P] java.util
（提供基础的工具设施）

				  包含集合框架、遗留的 collection 类、事件模型、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组、日期Date类、堆栈Stack类、向量Vector类等）

					- 集合框架部分 collection framwork
（集合框架是为表示和操作集合而规定的一种统一的标准的体系结构，能够通过统一的接口设计的不同类。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。）

						- 接口的继承关系

							- [I] java.util.RandomAccess 
标识支持随机访问

							  源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。

							- [I] java.util.iterator<E> 
支持从前往后顺序访问和增加元素
继承关系：继承自[I] java.lang.Iterable
迭代器

							  包含方法：
							  E next();
							  boolean hasNextO;
							  void remove0;
							  default void forEachRemaining(Consumer<? super E> action);

								- [I] java.util.Listlterator
支持任意方向顺序访问和增加元素

							- [I] java.util.comparator<E> 
支持元素比较

							  包含方法：
							  E next();
							  boolean hasNextO;
							  void remove0;
							  default void forEachRemaining(Consumer<? super E> action);

							- [I] java.util.collection <E> 
提供基本的增查删清、迭代器、提供size信息、提供hashcode信息、转为数组对象的方法，

								- [I] java.util.List<E>
有序集合ordered collection，支持通过索引随机访问random access

								  void add(int index, E element)
								  void remove(int index)
								  E get(int index)
								  E set(int index, E element)

								- [I] java.util.Set<E>
无序集合unordered collection，不允许有重复的元素
能够快速查找

									- [I] java.util.SortedSet
增加了比较器，用于排序（？）

										- [I] java.util.NavigableSet
增加了搜索功能

								- [I] java.util.Queue<E> 

							- [I] java.uti.map<E> 
增加键值映射等方法

								- [I] java.util.SortedMap
增加了比较器，用于排序

									- [I] java.util.NavigableMap
增加了搜索功能

						- 集合类的继承关系

							- [C] java.util.AbstractCollection

								- [C]  java.util.AbstractList
设计功能：List<E>接口的基础实现
继承关系：public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>

									- [C]  java.util.ArrayList
设计功能：一种可以动态增长和缩减的索引序列，非线程同步，支持高效的随机访问
内部存储：数组，有序集合
其他实现的接口：
比较器需实现comparable接口
实现了RandomAccess接口

									  因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。
									  
									  public class ArrayList<E> extends AbstractList<E>
									          implements List<E>, RandomAccess, Cloneable, java.io.Serializable

									- [C]  java.util.AbstracSequentialList
设计功能：增加顺序访问的支持

										- [C]  java.util.LinkedList
设计功能：一种可以在任何位置进行高效地插人和删除操作的有序序列，非线程同步，不支持高效的随机访问。可用作栈、队列和双向队列。
继承关系：List<E> + Queue<E>
内部存储：双向链表，有序集合
性能：可高效插入、删除元素
其他实现的接口：
比较器需实现comparable接口
没有实现RandomAccess接口

									- [C]  java.util.Vector
设计功能：和ArraysList接近，但所有方法都是线程同步的。ArraysList不是线程同步的。
内部存储：数组，有序集合


										- [C]  java.util.Stack

									- 备注：
list大类下 的遍历方式选择：

    实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach,
    未实现 RandomAccess接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环

								- [C]  java.util.AbstractSet

									- [C]  java.util.HashSet
设计功能：一种没有重复元素的无序集合
内部存储：哈希表（数组链表/链表散列），无序集合，非同步。基本上是对HashMap的包装
性能：查找性能O(1)
其他实现接口：判等器 hashcode()方法

										- [C]  java.util.LinkedHashSet
设计功能：一种可以记住元素插人次序的集
内部存储：哈希表（双向链表），无序集合
性能：查找性能O(1)
其他实现接口：判等器 hashcode()方法

									- [C]  java.util.TreeSet
设计功能：一种有序集，支持有序性操作，比如可根据一个范围快速查找元素的操作。 
内部存储：红黑树，有序集合
性能：查找性能O(logN)
其他实现接口：
比较器 compareTo()方法
									- [C]  java.util.EnumSet
设计功能：一种包含枚举类型值的集

								- [C]  java.util.AbstractQueue

									- [C] java.util.PriorityQueue<E>
设计功能：优先级队列
内部存储：堆
性能：

									  在 Queue 中 poll()和 remove()有什么区别？
									  
									  
									  poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

							- [C]  java.util.AbstractMap

								- [C]  java.util.HashMap
设计功能：一种存储键 / 值关联的映射表，线程不安全，允许Null键值
内部存储：哈希表（链表散列），无序集合；当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)
重要实现接口：判等器 hashcode()、equals()、containsKey()、containsValue()

								  当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头（头插法）,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。
								  
								  需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)

									- [C]   java.util.LinkedHashMap
设计功能：一种可以记住键 / 值项添加次序的映射表
内部存储：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

								- [I] java.util.SortedMap

									- [C]  java.util.TreeMap
设计功能：—种键值有序排列的映射表，适合遍历元素的操作
内部存储：红黑树

								- [C]  java.util.EnumMap
设计功能：一种键值属于枚举类型的映射表
								- [C]  java.util.WeakHashMap
设计功能：一种其值无用武之地后可以被垃圾回收器回收的映射表
								- [C] java.util.HashTable
和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。
它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，且因为 ConcurrentHashMap 引入了分段锁，效率会更高。
								- [C]  java.util.IdentityHashMap
设计功能：一种用 = 而不是用 equals 比较键值的映射表

									- ==与equals的区别

    ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
    ==是指对内存地址进行比较 equals()是对字符串的内容进行比较
    ==指引用是否相同 equals()指的是值是否相同

							- [C]  java.util.AbstractQueue

								- [C]  java.util.PriorityQueue
设计功能：一种允许高效删除最小元素的集合

							- [C] java.util.ArrayQueue
设计功能：一种用循环数组实现的双端队列

					- 字符串处理部分
string parsing and scanning

						- [C]  java.util.stringJoiner
						- [C]  java.util.string.Tokenizer

					- 事件模型部分
event model

						- [C]  java.util.eventObject
						- [C]  java.util.eventListener

					- 日期和时间
Date & Time

						- [C]  java.util.Calendar

							- GregorianCalendar它实现了世界上普遍使用的公历系统
							- import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

						- [C] java.util.date
						- [C]  java.util.Timer
定时器

							- [C] java.util.TimerTask

					- 国际化支持
internationalization support

						- [C] java.util.TimeZone

					- 编译信息
64位解码和编码
base64 encoding and decoding

						- [C] java.util.System

					- 其他工具类

						- 随机数生成器
random number generation

							- [C]  java.util.Random

						- 位数组
bit array

							- [C]  java.util.bitset

						- several miscellaneous utility classes

					- 其他部分等等

						- 遗留的集合类和遗留的时间类

				- [P] java.util.concurrent.*
（提供并发编程的工具设施）

					- [P] java.util.concurrent

						- 并发集合类
Concurrent Collections

							- [I] Queue
队列

								- [C] ConcurrentLinkedQueue
								- [I] BlockingQueue

									- [C] ArrayBlockingQueue
									- [C] DelayBlockingQueue
									- [C] LinkedBlockingQueue
									- [C] PriorityBlockingQueue
									- [C] SynchronousBlockingQueue

								- [I] Deque

									- [C] ArrayDeque
									- [C] LinkedList
									- [I] BlockingDeque

										- [C] LinkedBlockingDeque

							- 映射
[I] ConcurrentMap

								- [C] ConcurrentHashMap
								- [I] ConcurrentNavigableMap

									- [I] ConcurrentSkipListMap

							- [I] List
列表

								- [C] java.util.concurrent.CopyOnWriteArrayList<E>

									- 写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。

写操作需要加锁，防止并发写入时导致写入数据丢失。

写操作结束之后需要把原始数组指向新的复制数组。
									- 适用场景

CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。

但是 CopyOnWriteArrayList 有其缺陷：

    内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；
    数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。

所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。

							- [I] Set
集合

								- [C] java.util.concurrent.CopyOnWriteArraySet<E>
								- [C] java.util.concurrent.SkipListSet<E>

						- 线程执行器
Executor

							- Future

								- RunnableFuture

									- RunnableScheduledFuture
									- FutureTask

								- ScheduledFuture

							- Callable
							- Executor

								- ExecutorService

									- ScheduledExecutorService

										- ScheduledThreadPoolExecutor

									- ThreadPoolExecutor

							- CompletionService

								- ExecutorCompletionService

							- RejectedExecutionHandler
							- TimeUnit

						- 线程池
Executors

							- 提交方式
							- 回调接口
							- 拒绝策略

						- 同步工具类
Tools

							- [C]  java.util.concurrent.CountDownLatch
闭锁/倒计时计数器
							- [C] java.util.concurrent.CyclicBarrier
筹齐计数器
							- [C] java.util.concurrent.Semaphore
信号量

							  acquire()申请许可，可申请多份
							  release()释放许可

								- 它允许多个线程同时进入临界区。可以认为它是一个共享锁，但是共享的额度是有限制的，额度用完了，其他没有拿到额度的线程还是要阻塞在临界区外。当额度为1时，就相等于lock

						- Exchanger

					- [P] java.util.concurrent.Atomic
（提供原子变量类）

						- 引用的重要类或机制：
CAS
						- 说明：原子变量是多变的（？），不宜用来作为哈希表的键
原子变量并非是要取代java.lang包中的数据包装类
原子操作常和volatile修饰符一起用，保证线程安全性。
volatile可以看作是轻量级锁。
						- 基本类型

							- java.util.concurrent.atomic.AtomicInteger/AtomicLong/AtomicBoolean差不多

							  int addAndGet(int delta)
							            以原子方式将给定值与当前值相加。 实际上就是等于线程安全版本的i =i+delta操作。
							  
							  boolean compareAndSet(int expect, int update)
							            如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 如果成功就返回true，否则返回false，并且不修改原值。
							  
							  int decrementAndGet()
							            以原子方式将当前值减 1。 相当于线程安全版本的--i操作。
							  
							  int get()
							            获取当前值。
							  
							  int getAndAdd(int delta)
							            以原子方式将给定值与当前值相加。 相当于线程安全版本的t=i;i+=delta;return t;操作。
							  
							  int getAndDecrement()
							            以原子方式将当前值减 1。 相当于线程安全版本的i--操作。
							  
							  int getAndIncrement()
							            以原子方式将当前值加 1。 相当于线程安全版本的i++操作。
							  
							  int getAndSet(int newValue)
							            以原子方式设置为给定值，并返回旧值。 相当于线程安全版本的t=i;i=newValue;return t;操作。
							  
							  int incrementAndGet()
							            以原子方式将当前值加 1。 相当于线程安全版本的++i操作。 
							  
							  void lazySet(int newValue)
							            最后设置为给定值。 延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。
							  
							  void set(int newValue)
							            设置为给定值。 直接修改原始值，也就是i=newValue操作。
							  
							  boolean weakCompareAndSet(int expect, int update)
							            如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但不 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。

						- 引用类型

							- java.util.concurrent.atomic.AtomicReference和基本类型差不多

						- 数组类型

							- java.util.concurrent.atomic.AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray差不多

							  void set(int i, int newValue)
							  void lazySet(int i, int newValue)
							  int getAndSet(int i, int newValue)
							  boolean compareAndSet(int i, int expect, int update)
							  boolean weakCompareAndSet(int i, int expect, int update)
							  int getAndIncrement(int i)
							  int getAndDecrement(int i)
							  int getAndAdd(int i, int delta)
							  int incrementAndGet(int i)
							  int decrementAndGet(int i)
							  int addAndGet(int i, int delta)

						- 原子变量类更新器

							- java.util.concurrent.atomic.AtomicIntegerFieldUpdater<T>/AtomicLongFieldUpdater<T>/AtomicReferenceFieldUpdater<T,V>是基于反射的原子更新对象字段的值。

						- AtomicMarkableReference类描述的一个<Object,Boolean>的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。
						- AtomicStampedReference类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比AtomicMarkableReference类的<Object,Boolean>，AtomicStampedReference维护的是一种类似<Object,int>的数据结构，其实就是对对象（引用）的一个并发计数。但是与AtomicInteger不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。

					- [P] java.util.concurent.locks
（提供锁机制）

						- 说明：
锁机制存在以下问题：
（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。
（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。
						- 接口的继承关系

							- [I] java.util.concurent.locks.Lock
							- [I] java.util.concurent.locks.Condition
							- [I]  java.util.concurent.locks.ReadWriteLock

						- 类的继承关系

							- 同步器/同步工具类
Synchronizer

								- [C] java.util.concurrent.locks.AbstractQueuedSynchronizer，简称AQS

							- 锁
locks

								- [C]  java.util.concurrent.locks.ReentrantLock

									- 和Sychronized相比的特点：
同样是可重入锁，但增加了可中断、可限时、可选择公平锁或非公平锁，可绑定多个Condition的特点

								- [C]   java.util.concurrent.locks.ReentrantReadWriteLock

								  private static ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock(); 
								  private static Lock readLock = readWriteLock.readLock(); 
								  private static Lock writeLock = readWriteLock.writeLock();

									- ReadWriteLock是区分功能的锁。读和写是两种不同的功能，读-读不互斥，读-写互斥，写-写互斥。

								- [C] java.util.concurrent.locks.stampedLock

									- 该类是一个ReadWriteLock锁的改进，它的思想是读写锁中读不仅不阻塞读，同时也不应该阻塞写。

								- [C] java.util.concurrent.locks.LockSupport
								- 联系至synchronized关键字

									- 不要synchronized一个不变对象，因为此类对象每次都是新的，例如 Integer String 等

				- [P] java.util.regex
（支持正则表达式）

			- [P] java.io.*
（提供虚拟机层面I/O操作的支持）

				- 磁盘操作

					- [C] File
用于表示文件和目录的信息，但是它不表示文件的内容。File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。

						- [C] Paths
						- [C] Files

				- 字节操作
按操作对象分为文件、管道、数组、基本数据类型、对象序列化、缓冲操作、字节字符流转化控制、打印控制

				  以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。

					- [C] InputStream字节读取

						- 节点流

						  直接与数据源相连，读入或读出。

							- [C] FileInputStream
介质流，从File本地文件中读取数据

							  /**  * 复制文件:一边读，一边写  */ 、class hello { public static void main(String[] args) throws IOException { if (args.length != 2) { System.out.println("命令行参数输入有误，请检查"); 
							  System.exit(1); 
							  }
							   File file1 = new File(args[0]); 
							  File file2 = new File(args[1]); 
							  if (!file1.exists()) {
							   System.out.println("被复制的文件不存在"); 
							  System.exit(1); 
							  } 
							  InputStream input = new FileInputStream(file1); 
							  OutputStream output = new FileOutputStream(file2); 
							  if ((input != null) && (output != null)) { int temp = 0;
							   while ((temp = input.read()) != (-1)) { output.write(temp);
							   } } 
							  input.close(); 
							  output.close(); 
							  } }

							- [C] PipedInputStream
是从与其它线程共用的管道中读取数据。PipedInputStream的一个实例要和PipedOutputStream的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作。

							  /**  * 消息发送类  * */ 
							  class Send implements Runnable { private PipedOutputStream out = null; public Send() { out = new PipedOutputStream(); } public PipedOutputStream getOut() { return this.out; } public void run() { String message = "hello , Rollen"; try { out.write(message.getBytes()); } catch (Exception e) { e.printStackTrace(); } try { out.close(); } catch (Exception e) { e.printStackTrace(); } } }
							  
							  作者：小明
							  链接：https://zhuanlan.zhihu.com/p/28286559
							  来源：知乎
							  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
							  
							  /**  * 接受消息类  */ class Recive implements Runnable { private PipedInputStream input = null; public Recive() { this.input = new PipedInputStream(); } public PipedInputStream getInput() { return this.input; } public void run() { byte[] b = new byte[1000]; int len = 0; try { len = this.input.read(b); } catch (Exception e) { e.printStackTrace(); } try { input.close(); } catch (Exception e) { e.printStackTrace(); } System.out.println("接受的内容为 " + (new String(b, 0, len))); } } /**  * 测试类  */ class hello { public static void main(String[] args) throws IOException { Send send = new Send(); Recive recive = new Recive(); try { //管道连接 send.getOut().connect(recive.getInput()); } catch (Exception e) { e.printStackTrace(); } new Thread(send).start(); new Thread(recive).start(); } }

							- [C] ByteArrayInputStream
介质流，从Byte数组中读取数据

							  public static void main(String[] args) throws IOException { String str = "ROLLENHOLT"; ByteArrayInputStream input = new ByteArrayInputStream(str.getBytes()); ByteArrayOutputStream output = new ByteArrayOutputStream(); int temp = 0; while ((temp = input.read()) != -1) { char ch = (char) temp; output.write(Character.toLowerCase(ch)); } String outStr = output.toString(); input.close(); output.close(); System.out.println(outStr); }

						- 处理流，和节点流配合使用

						  与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。

							- [C] ObjectInputStream
装饰流（装饰模式），对象反序列化
							- [C] FilterInputStream

								- [C] BufferedInputStream

								  public static void main(String[] args) throws IOException { BufferedReader buf = new BufferedReader( new InputStreamReader(System.in)); String str = null; System.out.println("请输入内容"); try{ str = buf.readLine(); }catch(IOException e){ e.printStackTrace(); } System.out.println("你输入的内容是：" + str); }

								- [C] DataInputStream
直接读入一个8个字节的long类型或4个字节的float类型，无需把基本类型转换成字符串输出
								- [C] LineNumberInputStream
								- [C] PushbackInputStream

							- [C] SequenceInputStream
可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取
							- [C] StringBufferInputStream
介质流，从StringBuffer对象中读取数据

					- [C] OutputStream字节写出
和InputStream有对应关系

						- 节点流

						  直接与数据源相连，读入或读出。

							- [C] FileOutputStream
介质流，向File本地文件中写入数据
							- [C] PipedOutputStream
							- [C] ByteArrayOutputStream
介质流，向Byte数组中写入数据

						- 处理流，和节点流配合使用

						  与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。

							- [C] ObjectOutputStream
对象序列化，把封装的对象直接输出，而不是一个个在转换成字符串再输出
							- [C] FilterInputStream

								- [C] BufferedOutputStream
介质流，向StringBuffer中写入数据
								- [C] DataOutputStream
直接输出一个8个字节的long类型或4个字节的float类型，无需把基本类型转换成字符串输出
								- [C] printStream

								  public static void main(String[] args) throws IOException { File file = new File("/Users/liuluming/Documents/hello.txt"); // 此刻直接输出到屏幕 System.out.println("hello"); try { System.setOut(new PrintStream(new FileOutputStream(file))); } catch (FileNotFoundException e) { e.printStackTrace(); } System.out.println("这些内容在文件中才能看到哦！"); }

				- 字符操作

				  以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。

					- [C] Reader字符读取

						- 节点流

						  直接与数据源相连，读入或读出。

							- [C] CharArrayReader
							- [C] StringReader
							- [C] InputStreamReader

								- [C] FileReader

							- [C] PipedReader
							- [C] FilterReader

								- [C] PushbackReader

						- 处理流，和节点流配合使用

						  与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。

							- [C] BufferedReader 
带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。

								- [C] LineNumberReader

							- 转换流

							  可对读取到的字节数据经过指定编码转换成字符

								- [C] InputStreamReader

								  String fileName= "d:"+File.separator+"hello.txt"; 
								  File file=new File(fileName); 
								  Writer out=new OutputStreamWriter(new FileOutputStream(file)); 
								  out.write("hello"); 
								  out.close();

					- [C] Writer字符写出
和Reader有对应关系

						- 节点流

						  直接与数据源相连，读入或读出。

							- [C] CharArrayWriter
							- [C] StringWriter
							- [C] PipedWriter

						- 处理流，和节点流配合使用

						  与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。

							- [C] BufferedWriter
							- 转换流

							  输出流转到写流；

								- [C] OutputStreamWriter

								  String fileName= "d:"+File.separator+"hello.txt"; File file=new File(fileName); Reader read=new InputStreamReader(new FileInputStream(file)); char[] b=new char[100]; int len=read.read(b); System.out.println(new String(b,0,len)); read.close();

									- [C] FileWriter

							- [C] printWriter

				- 对象操作

					- Serializable
序列化

				- 网络操作

					- Socket

			- [P] java.nio.*
（提供操作系统层面I/O操作的支持）

				- java.nio
				- I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。

面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。

面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。

I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。

			- [P] java.net.*
（提供网络编程的工具设施）

				- socket

		- 开发商扩展包
javax.Extension Package

			- [P]  javax.servlet.*
服务器数据库中间层设施

		- 集成库
Integration Libraries

			- IDL

				- Java IDL（Interface Definition Language，接口定义语言）为 JavaTM 平台添加了 CORBA（Common Object Request Broker Architecture，公用对象请求代理体系结构）功能，从而可提供基于标准的互操作性和连接性。

			- JDBC

				- JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序

			- JNDI

				- JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。

			- RMI

				- RMI(Remote Method Invocation，远程方法调用)是用Java在JDK1.2中实现的，它大大增强了Java开发分布式应用的能力。Java作为一种风靡一时的网络开发语言，其巨大的威力就体现在它强大的开发分布式网络应用的能力上，而RMI就是开发百分之百纯Java的网络分布式应用系统的核心解决方案之一。其实它可以被看作是RPC的Java版本。但是传统RPC并不能很好地应用于分布式对象系统。而Java RMI 则支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。

			- RMI-IIOP

				- RMI以Java为核心，可与采用本机方法与现有系统相连接。IIOP，Internet Inter-ORB Protocol(互联网内部对象请求代理协议)，它是一个用于CORBA 2.0及兼容平台上的协议。

			- Scripting

				- 动态语言支持

### Java EE Development Kit

- JMS

	- 什么是Java消息服务、JMS消息传送模型
	- 基本概念

JMS是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。

消息模型

○ Point-to-Point(P2P)
○ Publish/Subscribe(Pub/Sub)
即点对点和发布订阅模型

- JMX

	- java.lang.management.*、 javax.management.*
	- 所谓JMX，是Java Management Extensions(Java管理扩展)的缩写，是一个为应用程序植入管理功能的框架。用户可以在任何Java应用程序中使用这些代理和服务实现管理。
一、JMX架构图

- [P] javax.servlet.*

	- [P] javax.servlet
（描述和定义servlet类与运行时环境之间的约束，约束是由符合规范的servlet容器为此类实例提供的）

		- [I] javax.servlet.servlet

		  //Servlet的生命周期:从Servlet被创建到Servlet被销毁的过程
		  //一次创建，到处服务
		  //一个Servlet只会有一个对象，服务所有的请求
		  /*
		   * 1.实例化（使用构造方法创建对象）
		   * 2.初始化  执行init方法，加载初始的数据
		   * 3.服务    执行service方法，处理客户端请求
		   * 4.销毁    执行destroy方法，销毁实例
		   */
		  public class ServletDemo1 implements Servlet {
		      //public ServletDemo1(){}
		      //生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次
		      public void init(ServletConfig arg0) throws ServletException {     System.out.println("=======init=========");
		          }
		  
		      //生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法
		      public void service(ServletRequest arg0, ServletResponse arg1)
		              throws ServletException, IOException {
		          System.out.println("hehe");
		  //在适当的时候调用 doGet、doPost、doPut，doDelete 等方法
		      }
		  
		      //生命周期方法:当Servlet被销毁时执行该方法
		      public void destroy() {
		          System.out.println("******destroy**********");
		      }
		  //当停止tomcat时也就销毁的servlet。
		  
		      public ServletConfig getServletConfig() {
		  
		          return null;
		      }
		  
		      public String getServletInfo() {
		  
		          return null;
		      }
		  }

		- [AC] javax.servlet.GenericServlet

		  abstract class GenericServlet implements Servlet, ServletConfig
		  - $ trServletConfig
		  + init()
		  + service()
		  + destroy()

	- [P] javax.servlet.http

		- [C] javax.servlet.http.HttpServlet
继承自GenericServlet

### Java ME

- 基本不用

## 最佳实践：
Java编程中的最佳实践
高性能Java

*XMind: ZEN - Trial Version*