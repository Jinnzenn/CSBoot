# 1.1 抽象数据结构 Abstract Data Structure

from
基本数据结构
Data Structure
to
高级数据结构
Advanced Data Structure

数据结构是一种存储和使用（大量）数据的方式

《数据结构》邓俊辉
《算法导论》 CLRS

## 抽象数据结构的概念

## 逻辑结构和存储结构

### 逻辑结构

- 静态集合
- 动态集合

## 逻辑上无关系：
集合结构（不相交集合）

## 逻辑上为一对一的关系：
线性结构

### 基本线性结构-序列 sequence：
向量 Vector
（线性表的顺序表示/顺序存储）

- 特性/动机：循秩访问 call by rank
- 逻辑结构：可看作一维数组的抽象和泛化
- ADT

	- 实现

- API功能接口

	- 常规向量

	  增查改删

		- 置乱器、判等器、比较器
		- 排序器

			- 起泡排序

			  稳定算法 stable algorithm

				- 实现
				- T(n) = Θ(n^2)

			- 归并排序

				- 实现
				- T(n) = Θ(nlogn)

		- 无序查找 find(e, lo, hi)
顺序查找 sequential search

		  输入敏感

			- 实现
			- 性能分析：
最坏情况/平均情况 T(n) = Θ(n)
最好情况  T(n) = O(1)

		- 插入 insert(r,e)

			- 接口的功能语义
			- 向量扩容的分摊分析
			- 实现
			- 性能分析：
最坏情况/平均情况 T(n) = O(n)
最好情况  T(n) = O(1)

		- 区间删除 remove(lo, hi)/单元素删除remove(r)

			- 实现
			- 性能分析：
最坏情况 T(n) = O(n)
最好情况 T(n) = O(1)

		- 唯一化 deduplicate()

			- 实现
			- 性能分析：
T(n) = O(n^2)

		- 遍历 traverse( VST & visit)

			- 实现
			- 性能分析：
T(n) = O(n)

		- 其他API

			- 交换 swap()
			- 倒置 reverse()

	- 有序向量

	  增查改删

		- 比较器
		- 有序性甄别 disorder()

			- 实现
			- 性能分析：
T(n) = O(n)

		- 唯一化 uniquify()

			- 实现
			- 性能分析：
T(n) = O(n)

		- 查找 search(e, lo, hi)

			- 查找长度：渐进分析时，常数项系数的大小
			- 二分查找 binary search

			  不断优化，提高稳定性

				- 实现
				- 性能分析：
最坏情况/平均情况 T(n) = O(logn)
最好情况  T(n) = O(1)
查找长度：
成功/失败 O(1.5·logn)

			- Fibonacci查找 Fibonacci search

				- 实现
				- 性能分析：
最坏情况/平均情况 T(n) = O(logn)
最好情况  T(n) = O(1)
查找长度：
成功/失败 O(1.44·logn)

			- 插值查找  interpolation search

				- 前提，已知向量中元素排列附和某种概率分布

					- 对于均匀分布的情况，插值查找每次查找区间缩短极快
d(n) = d(n-1) ^ 0.5
T(n) = O(loglogn)

				- 实现

		- 插入、删除、遍历上同常规向量没有区别

- 由于采用顺序存储，需要关注空间管理问题

	- 静态空间管理
	- 动态空间管理

		- 加倍扩容策略

			- 分摊分析：
单次O(1)

		- 增量扩容策略

			- 分摊分析：
单次Θ(n)

		- 缩容

- 派生

	- 顺序表 Sequence List
	- bitmap？

		- 用于大规模集合的数据存储和记录
		- 相关算法计算？？？

### 基本线性结构—序列 sequence：
列表 List
（线性表的链式表示，链式存储）

- 特性/动机：循位置访问 call by position
- 逻辑结构：可看作链表结构的抽象和泛化
- ADT

	- 实现

- API功能接口

	- 列表节点

		- ListNode模板类

			- data() pred()  succ()  insertAsPred() insertAsSucc()

	- 列表

		- List模板类

			- size() first() last() insertAsFirst() insertAsLast() 
insertBefore(p, e) insertAfter(p, e)...

	- 常规列表

		- 查找 fine(e)/find(e,p,n)

		  输入敏感

			- 实现
			- 性能分析：
最坏情况/平均情况 T(n) = Θ(n)
最好情况  T(n) = O(1)

		- 指定节点前/后插入 position.insert(e)

			- 实现
			- 性能分析：
 T(n) = O(1)

		- 区间删除 remove(posion T)

			- 实现
			- 性能分析：
 T(n) = O(1)

		- 唯一化，遍历 同常规向量没有区别
		- 排序器

			- 插入排序

			  输入敏感的算法

				- 实现
				- 性能分析：
最坏情况/平均情况 T(n) = O(n^2)
最好情况  T(n) = O(n)

			- 选择排序

			  更为稳定

				- 实现
				- 性能分析：
最坏情况/最好情况/平均情况 T(n) =  Θ(n^2)

			- 归并排序

				- 实现

					- 应注意将子列表划分为等长

				- T(n) = Θ(nlogn)

	- 有序列表

		- 唯一化 uniquify()

			- 实现
			- 性能分析：
T(n) = O(n)

		- 查找 search(e, lo, hi)

			- 无序查找 find(e, lo, hi)
顺序查找 sequential search

			  无法使用二分查找，因为不能循秩访问

				- 实现
				- 性能分析：
最坏情况/平均情况 T(n) = Θ(n)
最好情况  T(n) = O(1)

- 衍生

	- 链表 Linked List

		- 单链表 Link List
		- 双向链表 Du-Link-List
		- 循环链表 Cir-Link-List

	- 静态链表

- 应用

### 栈 Stack
（操作受限的线性表，线性/链式存储）

- 特性/动机
- ADT

	- 实现

		- 数组实现
Array Implementation
		- 链表实现
Linked List Implementation

- API功能接口
- 应用

	- 逆序输出 特性

		- 进制转换算法

	- 递归嵌套 特性

		- {1, 2, 3, 4, ... , n}
栈混洗

禁形 forbidden pattern

			- 合法括号表达式判断算法

				- 合法表达式数量 catalan(n) = (2n)! / (n+1)! / n!

	- 延迟缓存 特性

		- 逆波兰表达式转换和计算

			- 转换规则
RPN中元字符（meta-cahracter）的约定
			- 中缀表达式语法检查：
转换过程中，新的操作符入栈时，操作数栈内元素应恰好比操作符栈元素多一个

- 派生

	- 顺序栈 Sequence Stack

		- 有初始化、销毁、判断空、清空、入栈、出栈、取元素的操作。

	- 孪生栈 

	  为提高空间利用率，在一个向量内部同时维护两个栈，分别以向量的首末元素为栈底，相向生长。
	  接口操作增加标志位

### 队列 Queue
（操作受限的线性表，线性/链式存储）

- 特性/动机
- 应用 
- ADT

	- 实现

		- 数组实现
Array Implementation

			- 队列 Sequence Queue

				- 非循环队列 SqQueue.rear++
				- 循环队列 SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize

		- 链表实现
Linked List Implementation

			- 链队列 Link Queue

- API功能接口
- 应用

	- 循环队列-循环分配器
	- 队列-银行排队模拟

### 串 String
（非数值处理的线性结构，存储结构一般为顺序存储）

- 特性/动机：匹配问题
- 应用
- ADT：串结构

	- 向量实现 char*

- API功能接口

	- indexOf
	- 串匹配

		- Brute-force蛮力算法

			- 性能分析：
最好情况 O(m)
最坏情况 O(mxn)

		- KMP算法

		  Next表/查询表，减少了回退（跳过部分无须再次比较的字符），也避免回溯（在Next表中取最大的t值）
		  
		  哨兵：Next[0] = -1 ，以使算法语义得到统一

			- 构造Next表
			- 分摊分析：
最坏情况 k=2i-j < 2n ，O(n)
构造时间 O(m)
总体 O(n+m)
			- 字符集规模越小，单次匹配概率越大，性能优势越明显

		- BM_BC算法

		  从末字符开始匹配
		  
		  bc表，根据文本串中的x寻找模式串中可用的x位置，也避免回溯（在bc表中取最靠右且秩小于j的x值）
		  
		  哨兵：bc[0] = -1 ，以使算法语义得到统一
		  
		  gs表，

			- 坏字符(bc, bad char)策略，构造bc表
			- 性能分析：
--空间--
|bc[ ]|
--预处理--
O(n + m)
--查找时间--
最好情况 O(n/m)
最坏情况 （仅有首字符不符） O(n x m)
			- 字符集规模越大，单词匹配概率越小，性能优势越明显

		- BM_GS算法

		  从末字符开始匹配
		  
		  gs表，根据文本串中的x寻找模式串中可用的子串位置，也避免回溯（在bc表中取最靠右且秩小于j的x值）

			- 好后缀(gs, good suffix)策略，构造gs表
			- 性能分析：
--空间--
|bc[ ]| + |gs[ ]|
--预处理--
O(n + m)
--查找时间--
最好情况 O(n/m)
最坏情况 O(n + m)
			- 字符集规模越大，单词匹配概率越小，性能优势越明显，且对于匹配概率增大的情况，表现由于BM_BC

		- Karp-Rabin算法

			- 散列压缩 模式串“指纹”
			- 快速指纹（hash值）计算

### 线性表的推广

- 多维数组 
（放置同一类型数据，顺序存储）

	- ADT

		- 比如矩阵
		- 比如多槽位的哈希表

	- API功能接口

		- 不做插入和删除操作
		- 二维有序数组的马鞍查找 saddleback search

- 广义表/列表 Lists
（放置不同类型数据，链式存储）

	- ADT

		- 比如链式法的哈希表
		- 实现

			- 扩展线性链表表示
			- 头尾链表存储表示

	- API功能接口

## 逻辑上介于其他关系类型之间的结构
半线性结构

### 直接寻址表
（顺序存储）

- 特性/动机：循数值访问 call by value

  杂凑 = 哈希 = 散列
  
  一种思想

	- 关键码和地址之间拥有映射关系

- 逻辑结构：从数组推广得到
- 适用于关键字的全域范围比较小时
- 派生

	- 字典

### 散列表 Hash Tables
/桶数组
（散列存储）

普通数组的推广

- 特性/动机：循数值访问 call by value
散列 Hashing 思想

  杂凑 = 哈希 = 散列
  
  一种思想

	- 失去有序性
	- 关键码和地址之间拥有映射关系

- ADT抽象数据结构

	- 基于数组实现

		- 桶单元

	- 确定合适的散列表大小

		- 过大，存储空间大，过小，查找时间长；理想 S(n) = Θ(n)
		- 动态表 Dynamic Tables

			- 表扩张-每次倍增
单次插入的代价高，但均摊至平均每次插入代价为 O(1)
			- 表收缩-每次减半 
预留内存 物理
			- 性能分析：
分析思路和动态数组一致，都是采用摊还分析的方法

	- 构造散列函数

	  明确
	  快速
	  满射
	  均匀 distribute keys uniformily into slots
	  
	  regularity m key distribution should not affect uniformity

		- 什么是好的散列函数
		- 普通方法

			- 除余法

				- h(k) = k mod m，m是哈希表的slot数

			- 倍增法

				- 类似使用幸运转盘

			- multiply-add-divide
			- selecting digits
			- 平方取中mid-square
			- folding
			- 位异或法XOR
			- (伪）随机数法 rand

			  依赖平台和历史版本，慎用

			- 多项式法

			  key ---- hashcode

		- 全域哈希 universal hashing

		  构造散列函数族，使其具备全域 universal 性质。
		  全域：对于所有的不相等关键码x和y，使x和y的散列值相等的函数h的个数等于|H|/m 
		  从而：随机选一个函数hi，所有关键码都用这个函数散列，P{ 还没确定函数hi时，hi(x)=hi(y)且x!=y }= 使hi(x)=hi(y)相等的函数个数 / 函数的总个数
		  = ( |H|/m ) / |H| = 1/m
		  从而：设h是从哈希函数全域集H中随机选出的函数h. h被用作把任意n个键映射到表T的m个槽中，对给定键值x,我们有定理：E[#collision with x]<n/m

			- 动机：单纯使用一个散列函数时，能够构造键集，使得映射得到的散列值相同。构造一个散列函数族H包含|H|个散列函数，把所有的关键字散列成0～m-1的哈希值。随机选择散列函数，可以避免单独使用散列函数的缺点。从而具有理想的哈希性质，期望上，不同键值被映射到同一bucket的概率为n/m，即装载因子 load factor
			- 构造全域哈希的方法：

			  首先选择一个足够大的质数p,使得所有的键值都在0-p-1之间。且设Zp
			  
			  表示{0,1,...,p-1},设
			  
			  Z∗p
			  
			  表示{1,2,..,p-1}. 因为槽m的数量少于key的数量，所有m<p.
			  
			  然后我们就可以设计哈希函数了，设任意的a∈Z∗P,b∈Zp
			  
			  ,然后
			  
			  ha,b(k)=((ak+b)modp)modm
			  
			  所有这样的哈希函数族为:
			  
			  Hp.m={ha,b:a∈Z∗p,b∈Zp}
			  
			  例如：选定p=17，m=6,h3,4(8)=5
			  . 每个哈希函数都是将Zp映射到Zm
			  
			  . 我们还
			  
			  可以看到这个哈希函数族共有p(p-1)个哈希函数

		- 完全哈希/完美散列 perfect hashing

		  完全哈希采用二级结构，每一级上都采用 全域散列。第一级同带链接的散列表基本上是一样的，且存储有第二级使用的散列函数，第二级使用较小的二次散列表secondary hash table，因为使用全域哈希，从而保证第二级中不会有元素碰撞 collision 。表S_j的大小m_j为散列入slot j 的关键码n_j的平方。

			- 动机：完美解决普通哈希的问题

				- 但一般情况下，完美散列无法保证存在
				- 适用于静态static集合的散列存储，比如编程语言保留字的存储

			- 第二级散列表中，表S_j的大小m_j为散列入slot j 的关键码n_j的平方。
从而，设h是从哈希函数全域集H中随机选出的函数h. h被用作把任意n个键映射到表T的m个槽中，对给定键值x,我们有定理：E[#collision with x]< (n^2-n)/2 / n^2 < 1/2
			- 性能分析：
使用时，查找复杂度 T(n) = O(1)
存储空间期望值 S(n) = O(n)

	- 排除散列冲突

	  考虑 查找、插入、删除的复杂度
	  考虑数据访问的局部性
	  考虑I/O操作访问外存的情况

		- 封闭选址 closed addressing

			- 动机：解决键值可能映射到同一bucket的问题
			- 多槽位 multiple slots

			  有效利用的空间少

				- 为每个桶单元预备好更多槽位
				- 性能分析：
优点：如果槽位预留适当，效率依然O(1)
缺点：预留过多，空间浪费。另外无法处理极端情况——某一桶内需要大量槽位

			- 独立链/链表法 
separated chaining/linked-list chaining 

			  未利用系统缓存
			  动态申请内存空间所需时间长 10^2

				- 桶单元内放置指针，构成链表
				- 性能分析：
优点：克服了多槽位的缺点
缺点：指针需要额外空间，动态申请内存（动态申请内存耗时比使用高速缓存耗时高两个数量级，未利用系统高速缓存的功能，实际运行效率可能降低。

			- 公共溢出区

			  公共溢出区规模增大，处理冲突的成本增加

				- 单独开辟一块内存用于存放冲突的键值
				- 性能分析：
处理冲突的成本随着公共溢出区规模的增大线性增加

		- 开放选址 open addressing

		  利用高速缓存

			- 动机：封闭选址不够灵活，采用事先约定的方法确定每个bucket的备用桶查找方法，即预先定好查找链 probe sequence。如此组织哈希表，查找时，沿查找链依次查找直到找到匹配的关键码，若最终查找至空桶，查找失败
			- 线性试探 linear

				- 性能分析：
可能产生数据聚集 primary clustering和二次聚集 quadratic clustering现象，使得查找效率降低
				- 删除：懒惰删除

			- double hashing

				- h(k, i) = h1(k,) + i*h2(k) ，m=2^r，h2(k)为奇数
				- 性能分析：
假设每个关键码key等可能地分布在任一槽slot，且各自的试探序列probe sequence相互独立。装载因子alpha小于1

			- 平方试探

				- 动机：某些情况下，无法找出空桶，也就是部分内存无法得到利用
				- 性能分析：
在表长为素数，装填因子<=50%，能够找出所有空桶

			- 双向平方试探

				- 动机：基于双平方定理设计，能够进一步利用空间，减少查找链长度
				- M = 4 x k + 3，正向查找链和逆向查找链的前M项互异

				  双平方定理

			- 性能分析：
适当增大哈希表，也就是使装填因子足够小，可以减少开放选址的探查次数，减少查找用时

- API功能接口

	- 查找

		- 性能分析：
取决于最后构造出的哈希表的情况
最坏情况  集合内所有元素通过散列函数映射为同一哈希值，进入同一槽
查找操作的时间复杂度  T(n) = Θ(n)
平均情况  如能达到简单均匀哈希（simple uniform hashing），集合内的键值有平均的可能性随机映射至哈希表中
查找失败的时间复杂度 T(n) = Θ(1 + alpha)
：装载因子 alpha = n / m n个键值m个哈希表槽
：如果 n = O(m)，alpha = O(1)，查找失败复杂度可达到 O(1)

	- 插入
	- 删除

- 派生

	- 字典 dictionary

### 自组织表
self-organizing List
自调整列表
self-adjusting list
（链式存储）

- 竞争性分析

	- 定义：an on-line alg A is alpha-competitive, if exist const k such that for any sequence S of operarion:
Cost_A(S) <= alpha * Cost_god(S) + k
	- 使用摊还分析方法，分析不同启发式策略的代价
	- 离线算法-上帝算法 God's Alg

		- 预知整段操作序列

- 自组织表使用的是MTF(move to front)启发式策略

	- 如果采用数组结构，可以证明MTF策略是 4-competitive 算法，其摊还代价不会多于其他任何启发式策略（最好的应该就是God's Alg)的4倍。
	- 如果采用链表结构，无须逐个交换元素，则MTF策略可以达到2-competitive
	- 实际测试大概会快30%~40%

- 其他类似的有伸展树、操作系统中的分页置换策略 page replacement policy

### 跳跃表 Skip List
（链式存储）

- 特性/动机：提高有序链表的查找性能，考虑在部分或全部节点上增加额外的指针，以便查找时跳过若干点，不必从左到右连续查看。still call by position
- ADT抽象数据结构

	- 理想跳跃表
具有层次结构的链表，每一层次的节点间距大概是二倍比例增加（Flip the coin）

- API功能接口

	- 建表

		- Flip the coin 1/2概率的指示器随机变量

	- 查找

		- 算法

		  犹如乘地铁 快线、慢线的切换

			- 基于比较
			- 性能分析：
O(log n)

	- 插入

		- 算法

			- 1、查找
2、插入
3、表维护Flip the coin
			- 性能分析：
O(log n)

	- 删除

		- 算法

			- 1、查找
2、删除
3、表维护Flip the coin
			- 性能分析：
O(log n)

	- 性能分析：无论是单次，还是累计多次（可达到多项式量级），接口操作的时间复杂度【高概率】达到 O(log n).跳跃表的整体性能可以和二叉查找树（AVL 树，红黑树等）相媲美，其在 Redis 和 LevelDB 中都有广泛的应用。

- 回溯分析

## 逻辑上为一对多的关系：
树形结构/层次结构

### 树 Tree
（具有明显的层次结构，一般采用链式存储）

- 特性/动机：建立索引，兼具链表与向量的优点，既具有某种次序，又具有线性特征
- 应用

	- 表达式
	- 文件系统
	- URL

- ADT抽象数据结构

	- 树=连通无环图

		- 有根树：指定根(root)

- 功能接口

	- 插入 insert
	- 删除 delete
	- 查找 search
	- 遍历 iterator

	  三种

		- 中序遍历序列

			- 歧义性

		- 先序遍历
		- 后序遍历

- 派生

	- 二叉树

		- 特性

			- 具有普遍意义，任何一棵树可以转换为二叉树

		- 应用

			- 二叉编码树

				- PFC编码与解码

					- 特性：利用根通路串（root path string)不重复的特性编码前缀无歧义，解码过程不必回溯，但一旦某个比特位编码错误，解码可能大量出错
					- 解码过程

				- 最优编码树
optimal encoding tree

					- 平均编码长度最小--节点平均深度最小
					- 性质：双子性、层次性

				- Huffman编码树
=最优带权编码树

					- 考虑字符出现的概率

		- ADT

			- 真二叉树：任一内部节点都具有左右孩子
完全二叉树：叶节点深度差不超过1
			- BinNode + BinTree

		- API

			- 遍历 iterator

				- 算法与实现：
递归版 |迭代版

					- 中序遍历

						- 歧义性

							- 直接后继 succ() 
无论二叉树规模和机构如何，调用接口总和不超过O(n)
							- 直接前继

					- 层次遍历

						- 辅助队列Q的容量要求 不低于「n/2]
对于真完全二叉树，队列规模要求最大

					- 先序遍历
					- 后序遍历

				- 性能分析：
时间复杂度 T(n) = O(n)
辅助空间 O(n)

	- 多叉树

		- 特性：每个节点孩子均不超过k个的有根树，k叉树（k-ary tree）
		- 应用
		- ADT

			- public

		- API
		- 派生

			- 键树 Trie
/keyword tree
/digital search tree

				- 任一字符串集可表示为一颗键树

	- 搜索树

		- 循关键码访问 call by key
		- 二叉搜索树 BST

		  Binary Search Tree
		  局部的顺序性-全局的单调性
		  
		  任何一颗搜索树都可转为二叉搜索树

			- 动机：兼具向量与列表的优点

				- 局部顺序，全局单调

				  中序遍历的意义上全局单调

			- ADT抽象数据结构

				- BinNode 节点

					- BinNodePosi

				- Binary Search Tree 

			- API功能接口

				- 建树 built

					- 同快速排序quicksort类似
最好情况 O(n logn)
最差情况 Θ(n^2)
					- 随机构建二叉搜索树
randomly built BST
得到的树高height期望值为 O(log n)
：树高小，查找、插入、删除的速度较快
					- 随机化的二叉树排序
ramdonmized BST sort

				- 查找 search

				  中序遍历序列
				  二分查找

					- 算法

					  类似向量的二分查找
					  重点： hot变量的使用

						- 性能分析

					- 实现

				- 插入 insert

					- 算法

					  基于 查找 时的结构 注意hot和返回的值
					  hot是查找路径的终点

						- 性能分析

					- 实现

				- 删除 delete

					- 算法

					  基于search接口
					  removeAt(x, _hot)

						- 性能分析

					- 实现

			- 性能分析

				- 平均性能分析

				  树的高度h影响了各操作的性能

					- 统计口径：
随机生成

						- n!种BST
						- 高度 log(n)

					- 统计口径：
随机组成

						- Catalan种
						- 高度 根号n
						- 较为可信

				- BST平衡和高度的关系

					- 理想平衡 比如 CBT
适度平衡 比如 BBST

					  树的高度恰为 Log2(n)
					  条件太过苛刻

					- 平衡二叉搜索树
BBST

						- 等价 BST

						  上下可变，左右不乱
						  连接关系 承袭关系

						- 等价变换

						  局部操作，一系列基本操作串联而成 单次为O(1)，累计不超过O(logn)
						  zig(v) 顺时针方向 
						  zag(v) 逆时针方向
						  经过不超过O(n)次旋转，等价的BST可相互转化

		- 键树 /keyword tree
/数字查找树digital search tree

			- 动机：
任一字符串集可表示为一颗键树，某个节点包含组成关键字的一部分（字符），根通路串（root path string）组成一个关键字
			- 特性：每个节点的度数大于等于二
同层中，兄弟节点之间所含符号自左至右有序
			- ADT

				- 双链树

					- 以节点的长子+兄弟表示树

				- Trie树

					- 以树的多重链表表示树

			- API
			- 性能分析

				- 查找速度和HashTable基本相当，内存用量只有Hashtable一般不到，对于大容量的数据查找较为可行

		- 四叉搜索树？
		- 八叉搜索树

			- 八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。

				-     三维计算机图形
				-     最邻近搜索

	- 高级搜索树

		- 动机：局部顺序，全局单调

		  中序遍历的意义上全局单调

		- BBST:
AVL树
（适度平衡）

		  Georgy Adelson-Velsky and Evgenii Landis' tree, named after the inventors
		  以人名命名
		  适度平衡的证明  提示：fibonaci

			- 动机：左右子树的平衡将使得树高降低，减少复杂度

				- 平衡因子

				  平衡因子 balfal(v)
				  
				  左右子树高度差 绝对值不超过1

			- ADT抽象数据结构

				- 公有继承自BST
				- 最小失衡树

平衡二叉树插入新结点导致失衡的子树

			- API功能接口
（重平衡 Rebalance）

				- 查找

					- 公有继承自BST

				- 插入

					- 算法

					  zag-zag/zig-zig：单旋
					  zig-zag/zag-zig：双旋
					  
					  先执行BST的插入，再更新zigzag
					  
					  zigzag:
					  失衡的深度最深（最低）的祖先
					  以其 tallerchild的tallerchild 作rotate旋转

						- 3+4重构
connect34

						  编写
						  调试
						  维护
						  重用

						- rotate主要包括zigzag和connect34

					- 实现

					  效率为先

				- 删除

					- 算法

					  zig-zig/zag-zag
					  单旋 zig/zag和插入的方法是一致的  
					  
					  zig-zag/zag-zig 
					  双旋 先经一次zig/zag转化为单旋的情况
					  
					  主要考虑“失衡传播”

						- 3+4重构
connect34

						  编写
						  调试
						  维护
						  重用

						- rotate主要包括zigzag和connect34

					- 实现

					  基本轮子同插入相同，即rotate

			- 性能分析

				- 须引进平衡因子
				- 复杂度

					- 时间复杂度

						- 查找、插入、删除
最坏情况为O(logn)

					- 空间复杂度

						- O(n)

				- 相比理论，实测的复杂度更高，插入/删除的成本高（平均0.21次）
动态调整中，若采用删除操作全树拓扑结构的变化量可达 Ω（logn)
连续m次查找，m>>n，O(mlogn)

		- BBST:
伸展树  Splaytree
（适度平衡）

			- 动机：数据的访问具有局部性 Locality

			  节点的访问频率是有规律的
			  将高频节点移至根节点

				- 逐层伸展

				  效率主要取决于树的初始形态和节点的访问次序

					- 最坏情况：旋转次数呈周期性的算术级数演变 
每一周期累计Ω（n^2)，分摊Ω（n)

				- 双层伸展

					- 一旦访问最坏路径长度将会减半
分摊O(logn)

			- ADT抽象数据结构

				- 公有继承自BST

			- API功能接口

				- 查找 search

				  动态操作

					- 算法

					  采用双层伸展，利用双层伸展将降低树高，渐进意义上减半，并将目标节点移至根节点位置

						- 性能分析

					- 实现

					  从BST派生，增加Splay功能，重写查找、插入、删除功能

						- Splay 类似connect34的写法，采用拼接的方式
						- 查找 search 已不是静态接口，将调用Splay调整树的拓扑结构，返回目标节点或其父节点
						- 插入/删除算法 调用查找search接口

				- 插入 insert 
				- 删除 delete

			- 性能分析

				- 无须记录高度和平衡因子，不需要局部条件（局部树高度差不超过1）
				- 访问数据局部性强时，效率可以更高
连续m次查找，常被查找的为k，m>>n>>k，O(mlogk + nlogn)
				- 不能保证单次最坏情况，不适用对单次操作效率敏感的场合

		- BBST:
红黑树 RB-Tree

		  几何二分B-树
		  symmetric binary B-tree
		  
		  半平衡二分查找树
		  half-balanced binary search tree

			- 动机：降低存储不同版本数据结构的空间复杂度，更低成本地实现持久性数据结构

				- 至少优化至分摊空间复杂度 O(n+ h*log(n)），对于树结构O(n+h)，甚至，红黑树的版本间差异O(1)

				  h:版本数目

				- 红黑树能够做到不同版本间（进行一次操作后）拓扑结构变化O(1)

			- ADT抽象数据结构

				- 公有继承自BST
				- 由红黑节点组成的真二叉树

					- 黑高度

					  4条构造规则

					- Red-Blackness：
1 根节点为黑
2 叶结点为黑
3 每个叶结点至根节点的路径等长
4 红节点的父节点和子节点为黑

				- (2，4) B-Tree

					- 提升变换  lifting

					  是一种等价拓扑变换
					  类似zig zag

			- API功能接口

				- 查找 search

					- 算法

						- 继承自BST

					- 实现

				- 插入 insert

					- 算法

					  插入红节点
					  依据叔父节点的颜色调整

						- 3种情形，最坏可能需要双红修正

						  相当于修复B-Tree上溢

							- 3+4重构 3+4connect

							  局部基本操作
							  不超过常数

							- 染色 recolor

							  局部基本操作

						- 性能分析

							- 每一次插入操作，可在O(logn)时间内完成
							- 然而，AVL的插入操作也能达到O(logn)级别

					- 实现

				- 删除 delete

					- 算法

						- 可能需要双黑修正

						  相当于修复B-Tree的下溢

							- 3+4重构
							- 染色

						- 性能分析

							- 每一次删除操作，可在O(logn)时间内完成
							- AVL的删除操作不能达到O(logn)级别???

					- 实现

			- 性能分析
			- 派生

		- BmST（balanced m-way search trees)
B-树 B-Tree
（理想平衡）
（索引存储）

		  平衡的多路（multi-way）搜索树

			- 动机：不同存储层级间访问速度存在显著差异
需要减少I/O次数

			  不同存储方式访问速度的巨大差异 10^5
			  外存高效支持批量访问，而B-树的超级节点对应一组关键码
			  可针对外部查找，大大较少I/O次数

				- 因此，使用超级节点
分支（[m/2]，m）
节点数量  ([m/2]-1, m-1)

				  常用的m为200~300

			- ADT抽象数据结构

				- BTree

					- BTNode 节点

				- 水平方向是同一存储介质，垂直方向是不同存储介质。尤其适用于磁盘介质与内存之间的数据读取
				- （2，4）B-Tree拥有和红黑树一样的结构
红黑树也写作2-3-4 Tree

			- API功能接口

				- 查找 search

					- 算法

					  I/O操作规模主要取决于内外存交互页面page的大小
					  
					  节点中关键码存放为向量，顺序查找（不值得优化）
					  内存中的顺序查找和一系列IO操作间隔组成的操作序列
					  失败查找止于外部节点

						- 性能分析

							- I/O操作是最为耗时的
Θ(查找深度）=O(h)
h <= O(logm(N))
							- 更关注常数意义而非渐进意义下的时间复杂度
							- 若m=256 ,树高相对常规BBST大约为1/7~1/8，且变化幅度小

					- 实现

				- 插入 insert

					- 算法

					  在叶节点处插入，若结果不符合严格的b-tree
					  
					  分裂 split
					  上溢修复 solveoverflow

						- split、overflow
						- 性能分析

							- 最坏情况下，不断上溢至根节点
至多O(h) = O(log(N))

					- 实现

				- 删除 delete

					- 算法

					  经过交换，在目标位置的后继，也就是叶结点处删除，若结果不符合严格的B-tree
					  
					  若叶节点的左右兄弟关键码数量足够，作旋转操作
					  若不足够，作合并操作
					  下溢可能向上传播

						- spin、merge、overflow
						- 性能分析

							- 最坏情况下，不断下溢至根节点
至多O(h) = O(log(N))

					- 实现

			- 性能分析

				- 外存操作和内存操作的代价大致相当

		- BmST（balanced m-way search trees
B+树 B+Tree

			- 动机：B树
			- 红黑树、B 树、B+ 树的区别？

    红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些
    B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。

    一般化的二叉查找树（binary search tree）
    “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）

应用

    大部分文件系统、数据库系统都采用B树、B+树作为索引结构

区别

    B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。
    B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

B树的优点

对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。
B+树的优点

    非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。
    叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。

    B 树、B+ 树区别来自：differences-between-b-trees-and-b-trees、B树和B+树的区别


				- B+树与红黑树比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

（一）更少的查找次数

平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。

红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

（二）利用磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

		- B*树
		- 树堆 Treap

	- 以树形结构为基础改进的
动态数据结构
augmenting data structure

	  不一定是基于树结构实现
	  动态数据结构是选择某一种基础数据结构，在此结构上进一步扩张，以增加新功能

		- 如何进行数据结构扩张
data structure augmention

			- 使用基础数据结构自带的操作

		- 顺序统计树 order-statistic tree

			- 动机：支持快速顺序统计操作
			- ADT抽象数据结构

				- 以红黑树为基础，每个节点增加size属性
x.size = x.left.size + x.right.size + 1

			- API功能接口

				- 查找秩为i的元素

					- OS-select算法

						- 性能分析：
每层递归调用，树中下降一层，树高O(logn)
T(n) = O(logn)

					- 实现

				- 确定一个元素的秩

					- OS-rank算法

						- 元素的size属性是记录子树的规模，
而不是本身的秩，便于维护
						- 性能分析：
每层递归调用，树中上升一层，树高O(logn)
T(n) = O(logn)

					- 实现

				- 插入和删除

					- 算法

						- 元素的size属性是记录子树的规模，
而不是本身的秩，便于size属性的更新和维护
						- 性能分析：
维护更新size属性时的rotate、lifting等操作都只需要O(1)时间，渐进意义上同原红黑树的插入删除操作是一样的
同时，每次仅需在一条遍历的路径上的节点更新size属性，节点数量O(logn)
T(n) = O(logn)

					- 实现

		- 区间树  interval tree

			- 动机：支持集合内的查询目标区间
			- ADT抽象数据结构

				- 以红黑树为基础

			- API功能接口

				- interval-insert
				- interval-delete
				- interval-search

					- 算法

						- 返回与目标区间重叠的结点或者返回NIL
						- 性能分析：
T(n) = O(k logn)
k是重叠区间的元素数量
输出敏感算法

					- 实现

		- 线段树 segment tree
		- k-d树

			- 一维范围查询

		- 【14.1】红黑树的扩张定理

	- Radix Tree
	- Ternery Search Tree

### 优先级队列（堆）Priority Queue (Heap)
（逻辑结构上是树结构，存储上可以为顺序存储）

stack和queue可以看作优先级队列的特例

- 特性/动机：循优先级访问call by priority
多任务调度、优先级
- 应用

	- 霍夫曼编码算法
	- 扫描线算法

- ADT：PQ结构

	- 多种实现思路

		- 基于数组实现

- API功能接口

	- getMax
	- delMax

- 性能分析
- 派生

	- 完全二叉堆
PQ_complHeap

		- 应用

			- 堆排序算法

			  利用delMax来快速选择出未排序序列中的最大元素

				- 选择排序O(n^2)，堆排序O(n logn)
				- 就地算法

		- ADT抽象数据结构

			- 完全二叉树

			  仅在逻辑上实现
			  
			  一种AVL树，但 平衡因子为0 或 1，处处非负
			  
			  依照层次遍历顺序一一对应

				- 堆序性
				- 结构性

			- 向量 Vector

		- API功能接口

			- 接口规范
			- getMax
			- 插入 insert

				- 算法

				  上滤 percolate up
				  注意堆序性和结构性

					- 性能分析

						- 最坏情况O(logn)
平均意义下为O(1)

				- 实现

			- delMax

				- 算法

				  下滤 percolate down
				  
				  注意堆序性和结构性

					- 性能分析

						- 最坏情况O(logn)

				- 实现

			- 快速建堆 heapification

				- Floyd建堆算法

				  实现偏序结构即可
				  自顶而下的下滤

					- n/2放置在叶节点，剩余部分做下滤操作，最坏情况O(n)

				- 实现

	- 左式堆 LeftHeap

		- 动机/特性：快速实现堆合并
		- ADT抽象数据结构

			- 二叉树 BinTree

				- 堆序性满足，结构性已不满足
				- 左倾性

					- NPL（Null Path Length)

					  npl(x)=x到达最近外部节点的距离
					  =以x为根的最大满子树的高度
					  
					  用于衡量倾斜程度

				- 右侧链长度

					- O(logn)

		- API功能接口

			- 接口规范
			- 合并 merge

				- 算法

				  将a的右子堆，与b合并

					- O(logn)

			- 插入 insert 

				- 算法

			- getMax
			- delMax

				- 子主题 1

## 逻辑上为多对多的关系：
图形结构

### 图 Graph

- 特性/动机：其他结构的超集
- 应用

	- 表达式
	- 文件系统
	- URL

- ADT抽象数据结构

	- G(V,E)

		- 有向图 | 无向图 | 混合图

			- 无向边 | 有向边
			- 无向边可以等效地替换为一对有向边

				- 无向图和混合图可转化为有向图

		- 简单图

		  不含任何自环的图

			- 度

				- 入度
				- 出度

			- 通路和环路 | 自环

		- 带权图

			- 每一边都具有一定权重

	- 复杂度估计

		- |E| = Θ(V ^ 2)

			- 入度、出度
度数之和 = 2|E|

	- 邻接矩阵 adjacency matrix
向量表示

		- 性能分析：
T(n)  顶点编号可以用秩来表示，所以任一两点之间的关系可以O(1)时间找到。顶点/边的静态操作接口 T(n) = O(1)。顶点的动态操作如增加/删除新顶点时，较为耗时。分摊意义上为O(n)
S(n) 对称阵，一半的空间是冗余的

	- 邻接表 adjacency list
链表表示

		- 性能分析：
exist(v,u)需要O(n)的顺序查找时间

- API功能接口

	- 边操作接口

		- e() 边总数
		- 插入 insert(v, u)
		- 删除 delete
		- 。。。

	- 顶点操作接口

		- 遍历 iterator
		- 查找 search

			- 深度优先搜索 DFS
			- 广度优先搜索 BFS

		- 最小支撑树 prim
		- 最短路径 dijkstra
		- 双连通分量分解 bcc
		- 拓扑排序算法 
		- 。。。

- 派生

	- 最小生成树
minunum spanning tree

		- 贪心算法

## 进一步深入，计算几何相关课程

*XMind: ZEN - Trial Version*