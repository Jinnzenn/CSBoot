# 算法设计
Algorithm Design Technique

## 算法，任何良定义的计算过程，该过程取某个值或者值的集合作为输入，并产生某个值或值的集合作为输出。

算法也可以看作求解良说明的计算问题的工具。

算法设计，针对某特定问题提出高效的计算求解过程

## 算法设计的策略和方法
算法设计思想

典型设计策略和模式

### 算法的界定

- 经过有限步后终止

### 什么是好的算法

- 正确
- 健壮
- 可读
- 高效

### 递归法
（函数调用的一种特殊形式，允许函数和过程自我调用）

- 多分支递归

	- 二分递归

		- 线性递归
linear recursion
分解出的子问题之一可直接求解

			- 尾递归
tail recursion

### 迭代法
（程序循环）

### 分治策略(divide and conquer)

- 策略描述:
1、分解（Divide）将原问题步骤划分为一些子问题。划分结果中，若子问题和原问题形式一样，则称为递归情况recursive case，若子问题形式一样且规模足够小，不需要再划分时，则称为基本情况base case，若子问题和原问题形式不一样，则另做处理，在合并步骤中合并回原问题。
2、解决（Conquer）递归地求解子问题，直到达到基本情况。
3、合并（Combine）合并子问题的解成为原问题的解
- 举例：
归并排序、二分查找、乘方运算、斐波那契数计算

fibonacci数列 ”自顶而下“的递归算法做了太多重复的工作，递归树中有许多相同的子树，计算是不必要的，指数级。转换为“自底而上“的迭代方式，计算起来就快得多，线性。此外利用斐波那契数的乘方通式/矩阵通式，可以进一步缩短至O(logn)。

斯拉特森算法 stressan algorithm
一种矩阵相乘的算法，通过减少乘法次数降低算法复杂度

### 减治策略(decrease and conquer)

- 策略描述：
同分治策略类似，通过减治不断降低原问题的规模，并求解
- 举例

### 变治策略

### 动态规划(Dynamic Programming)

- 问题特征：
1.最优子结构。一个问题的最优解包含了其子问题的最优解。
2.重叠子问题。原问题的递归算法可以反复地解同样的子问题，而不是总是产生新的子问题
- 策略描述：
1、刻画一个最优解的特征
2、递归地定义一个最优解的值
3、计算最优解的值，通常采用自顶而上的方法
4、利用计算出的信息【构造】一个最优解

	- 带备忘的自顶向下法
top-down with memoization

		- 原问题和子问题的关系可以描述为递归调用树，递归调用树可以看作是子问题图 G=(V,E)，因此和图算法关系密切

	- 自底向上法
bottom-up method

### 贪心法(Greedy Algorithm)

- 问题特征：
满足动态规划条件的同时
Hallmark: Greedy choice property
局部最优解也是全局最优解
- 策略描述

### 试探-剪枝-回溯
（probing-pruning-backtracking

- 问题特征:
 问题的解可看作是元素构成的特定排列。搜索空间极大，可能近乎元素全排列 O(n^n)。
- 策略描述：
利用问题规律，在呈树状的搜索空间中，尽可能由解的局部特征尽早地批量排除候选解
- 举例：
旅行商问题 TSP(traveling salesman problem)
八皇后问题
迷宫寻径问题

### 随机化方法

- 指示器随机变量

*XMind: ZEN - Trial Version*