# 算法分析 Analysis of Algorithms

> 算法分析，一般指的是算法运行时计算机性能和资源利用的分析估计
>
> 软件开发中，除了性能，当然还有很多同样重要的方面，比如软件的安全性、可靠性、稳定性、可扩展性、健壮程度、用户友好程度等等，但性能当然是首要目标。

## 算法的分类

> 根据算法的类型，应该采用不同的分析方法。

### 直接算法/间接算法

- 直接算法：直接移动元素本身，适合较为简单的元素结构
间接算法：下标+关键码+指针，适合较为复杂元素结构

### 内部/外部 internal /external

- 算法的性能可能实际取决于内存/外存读取，通信带宽或计算机硬件这些资源
- 内部：就地算法 implace alg

### 离线/在线 offline/online

- 在线：一次只能读取一步操作
离线：一次可以读取整个序列的操作，因此具有优势

### 串行/并行 sequeial/parallel

### 确定性/随机 deterministic/randomized

### 基于比较式/散列式 comparison-based/hash-based

- CBA compared based alg
基于比较树的算法

	- algebraic decision tree
代数判定树是比较树的推广

## 算法分析的前提

### 可行性、有穷性

## 算法的正确性

### 算法正确性的性质

- 不变性，例如循环不变式
- 单调性

### 算法正确性的分析方法

#### 增量策略为代表的分析过程：
根据循环不变式确定算法的正确性（关键在于寻找不变性）

- 比如插入排序，循环不变式逐渐增加
- 采用迭代思路分解问题，算法复杂度表现为迭代式
1、初始化为真 2、每次迭代保持为真 3、迭代终止恰为结果
- 相对其他常数次的操作，循环结构中的操作次数更值得关注

## 算法的复杂度

### 影响因素：
对于同一算法的不同实例，算法的复杂度，即总体性能
1.取决于输入（input）本身的特点，比如有序程度，由此分为最坏情况、最好情况、平均情况（输入是随机的）、期望情况（纳入一个指示器随机变量）、分摊情况（估计多步操作的摊还代价）
2.取决于输入的规模，一般而言，算法输入规模和复杂度呈正相关。

### 时间复杂度

- 时间复杂度，即算法的运行时间，指的是算法执行过程中基本操作数或步数。在渐进分析时，不考虑操作系统、硬件等情况，主要考虑比较和交换等基本操作次数，而实际运行时，IO操作、非系统缓存（指针访问）等操作时间要长得多。

- 最坏情况运行时间
worst-case
- 最好情况运行时间
best-case

	- 假象（bogus）

- 平均情况运行时间
average-case

	- 期望值
需要知道 输入 的统计学意义分布
	- 输入是随机的

- 期望运行时间

  算法包含了一个指示器随机变量，复杂度由算法内含的随机数决定，也就是随机化算法

	- 指示器随机变量
indicator random viareble

- 分摊情况运行时间
amortized

### 空间复杂度

- 一般排除输出序列所需的空间，考虑计算过程中的辅助空间

### 算法复杂度的分析方法：

#### 复杂度的上界和下界

- 相对而言，在算法性能分析时，更值得关注的是上界（upper bound），也就是算法运行的最坏情况
- 算法性能优化时，考虑下界可以知道优化的极限，比如排序算法，下界不可能小于O(n)



#### 复杂度计算--一般方法

- 求复杂度的上界、确界和下界
- 常数次操作复杂度为O(1)
  - 常数代价准则 uniform cost criterion
    - 整数乘法、位移、打印
  - 对数代价准则 logarithmic cost criterion
    - 读取二进制比特位
  - 当参与运算的整数k不大时，两者差异不大，当k很大，超出机器字长之后，差异不容忽略
- 采用递归思路分解问题时，算法复杂度分析采用的是递归分析法：
  1、递推方程
  2、递归跟踪
  - 比如归并排序，分解问题为更小的子问题
  - 时间复杂度计算：
    1、代换法求递归式 substitution method
    2、递归树 recurtion-tree method
    3、主方法 master method  
    --> compare f(n) with (n^ logb(a))
    < : T(n) = Θ(n^ logb(a))
    = : T(n) = Θ(f(n)* logn) = Θ(n^ logb(a) * logn)

> : T(n) = Θ(f(n))

```java
  主方法有许多使用限制
  通过递归树可以较好地理解

	- 矩阵乘法的Strassen方法：
```

矩阵乘法可以写成递归过程，自然定义矩阵乘法的递归树中，有2^3 = 8 次乘法，运算过程的复杂度为 O(n^3)
Strassen方法通过式子变换，减少了乘法次数到7，增加了加法次数，运算过程的复杂度为 O(n^lg7)

```
- 空间复杂度计算：
```

若每个递归实例仅需常数规模空间，递归算法所需空间重量将线性正比于最大递归深度

- 采用迭代思路分解问题，算法复杂度表现为迭代式
  级数求和

#### 复杂度计算--输入规模的影响
###### 渐进分析 Asymptotic Analysis

- 算法的实际运行情况需要考虑到操作系统、硬件情况，具体比如内存使用，资源占用（网络，磁盘等） Memory requirement, Degree of parallelism, Resource use( cpu or gpu cycles, Disk IO etc), Accessibility(Cloud/local)

	- 相对速度 relative speed
	- 绝对速度 absolute speed

- 渐进分析忽略掉上述的环境因素，考虑在输入规模增加时算法的性能，仅从内存引用次数、基本操作次数考虑算法的复杂度
并且，总体上考虑增长的量级，摒弃输入规模足够大时可忽略的细节问题

	- 对于一个可计算问题，输入规模扩大，同一算法的时间复杂度不一定会单调增大。比如整数的素因子分解
	- 常用结论：
等差级数：与最大一项平方同阶
等比级数：与最大一项同阶
调和级数：Θ(lnn)

- 渐进分析的符号 Asymptotic notation
数学定义

	- Θ、Ο、ο、Ω、ω

- 封底估算
back of the envenlop calculation

	- 根据数据结构和算法的渐进复杂度，凭借实际环境积累的经验，针对计算过程主要部分进行粗略估算，粗略估算的技巧在于适当放大，比如10^3约等于2^10

#### 复杂度计算--输入实例的影响
输入敏感算法 input sensitive和输出敏感算法 output sensitive

平均复杂度

- 假定输入实例的出现符合某种概率分布，进而估算出加权平均复杂度。
对于排序算法，主要在于输入序列的有序程度，或者说输入序列中逆序对的数量

#### 复杂度计算--操作序列的影响
###### 分摊分析/摊还分析 Amortized Analysis

- 用来分析在操作某一数据结构时，最坏情况下单次操作的平均性能。不再割裂同一算法或数据结构的各次操作之间的因果关系
- 聚合分析 aggregate analysis

	- 确定n个操作的序列的总代价的上界T(n)
单次操作的平均代价为T(n)/n
平均代价作为每个操作的摊还代价，即使有多种类型操作，这里认为每种类型操作的摊还代价是相等的

- 核算法 accounting method

	- 前面操作剩下的预付信用prepaid credit可用来支付后续操作的差额。预估每一次操作的摊还代价，以会计的方式计算。

- 势能法 potential argument

	- 同核算法类似，但是使用势能函数将 预付信用 的整体储存起来，而不是同单个对象关联分开储存。

#### 回溯分析

- 举例：跳跃表的查找操作复杂度

#### 竞争性分析

- 比较不同策略和最优策略之间摊还代价的差异，得到上界，典型的为在线算法的摊还代价估算

#### 后向分析

## 算法的其他性能分析角度

#### 稳定性

稳定算法 stable algorithm

同值元素在算法执行之后顺序不变

#### 对硬件存储的利用

就地算法 inplace algorithm

比如原址排序，在相邻的内存位置间进行运算。充分利用了计算机内存和高速缓存

### 

*XMind: ZEN - Trial Version*