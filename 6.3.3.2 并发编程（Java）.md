# 并发编程

## 基础概念

### 并发
concurrency

- 并发现象：计算机系统的各个层面上都存在。多个逻辑控制流在时间上重叠，称作并发现象。
系统级并发：一种操作系统内核用来同时运行多个应用程序的机制。（这里自单个处理器）
应用级并发：一种应用程序通过逻辑控制流同时执行多项任务的机制。

	- 系统级并发：
操作系统中，一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行，但任一个时刻点上只有一个程序在处理机上运行。
	- 并行：当系统有一个以上处理器时,则线程的操作有可能非并发。比如当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

- 并发程序
concurrent program

	- 定义：
使用应用级并发的应用程序

		- 串行编程模型和并行编程模型

	- 构造并发程序的方法

		- 基于进程的
		- 基于I/O多路复用的
		- 基于线程的

## 基于进程的并发编程

## 基于I/O多路复用的并发编程

## 基于线程的并发编程
（在多处理器系统上有优势）

### 基础概念

- 同步和异步的概念

	- 同步与异步主要是从【消息通知机制】上发展出的概念。
同步的概念：就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。
同步的实现：体现在数据的访问上就是，在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。
	- 异步：异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。
异步的实现：在调用者和执行组件之间要能返回消息（执行结果），执行部件和调用者通过三种途径返回结果：状态、通知和回调。使用哪一种通知机制，依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。

- 阻塞调用和非阻塞调用的概念

	- 阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。

- 线程协作的四种方式

	- 同步阻塞
	- 异步阻塞
	- 同步非阻塞
	- 异步非阻塞

### 操作系统层面的并发编程（C语言）

- 线程执行模型

	- 主线程 main thread
	- 对等线程 peer thread
	- 线程的状态

		- 创建
		- 运行
		- 终止

- 线程内存模型

	- 程序代码的变量如何映射到内存？
	- 哪些是共享变量？

- 几种并发问题的解决

	- 并行性
多CPU的计算机系统，如何充分利用计算资源？

### JVM虚拟机层面的并发编程

- 线程执行模型

	- JVM中的程序、进程和线程

		- 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
		- 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。
		- 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享【同一块内存空间和一组系统资源】，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

	- 线程的状态

		- 初始状态：NEW
线程被构建，但是还没有调用start()方法
		- 运行状态：RUNNABLE
包含Running（运行中）和Ready（就绪）两种状态，两种状态间靠系统调度进行切换。

			- 可能抛出异常，跳至
Terminated

		- 阻塞状态： BLOCKED
线程被动阻塞，等待获取一个锁，获取到锁后状态才会切换至运行状态。

			- 可能抛出异常，跳至
Terminated

		- 等待状态/无限期等待：WAITTING
该线程主动等待，其他线程做出一些特定动作后（通知或线程中断指令），线程返回到运行状态。

			- 可能抛出异常，跳至
Terminated

		- 超时等待状态/限期等待：TIME_WAITTING
该线程等待其他线程做出一些特定动作（通知或线程中断指令），或者在指定时间后自行返回到运行状态。

			- 可能抛出异常，跳至
Terminated

		- 终止状态：Terminated
该线程已经执行完毕。

	- 线程中断
	- 线程的属性

- 线程内存模型

	- 线程隔离的区域：
虚拟机栈、程序计数器、本地方法栈
线程共享的区域：
堆、方法区

		- 共享变量在堆Heap中

- 几种并发问题的解决

	- 并行性
	- 线程安全

		- 线程安全性
		- 互斥同步

			- 实现方法

				- 内置锁=同步锁=监视器锁
synchronized关键字

					- 实现原理：
synchronized修饰的代码块在编译为字节码后，前后生成了monitorenter和monitorexit指令。
虚拟机的线程执行至monitorenter指令时，尝试获取对象的锁（通过monitorenter指令的reference参数找到对象，通过对象头的信息判断锁是否可获得）：
如果这个对象没有锁定，或者当前线程已经拥有了该对 象的锁，把锁的计数器+1； 当执行monitorexit指令时将锁计数器-1；当计数器为0时，锁就被释放了。如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

						- 底层依赖：
操作系统层面的互斥锁

					- 内存语义：
和其他的加锁释放锁的语义一样。
进入synchronized块的语义是把使用到的变量从线程的工作内存中清除，直接从主内存中获取需要的变量。
退出synchronized块的语义是将代码块内对变量的修改刷新到主存。
					- 锁定的对象：
1. 类锁：在代码中的静态static方法上加了synchronized的锁，或者synchronized(xxx.class）的代码段，对该对象的类对象加锁。
2.对象锁：在代码中的非静态方法方法上加了synchronized的锁，或者synchronized(this）的代码段，对该对象加锁。此时，对象内未被synchronized标注的实例方法仍然是可用的。
3.私有锁：在类内部声明一个私有属性如private Object ob，在需要加锁的代码段synchronized(ob）
					- 使用性质：
可重入：同一个线程，获取某个锁后，可以再次获取这个锁。避免阻塞。
非公平锁：在多个等待的线程中，并不是先到先得

*XMind: ZEN - Trial Version*