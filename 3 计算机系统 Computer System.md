# 计算机系统 Computer System 
-------------------------------
计算机系统

## 计算机系统的组成

### 计算机器件的硬件结构
（从局部到系统）

- 逻辑基础

	- 布尔代数 bool algebra

- 硬件基础

	- 二进制的电路实现 binary
（二进制表示数值和字母）

- 硬件构建块：
逻辑门 logic gate

	- 组合电路
字级组合电路
（使用电子电路来对位进行运算）

		- 时序电路
（用以实现有状态，并依据状态进行运算的系统）

			- 处理器
（位级数据计算）

				- 中央处理器 CPU
（内部也有存储器，
包括register和cache）

					- Register 寄存器文件/程序寄存器

						- 分类

							- 按功能分类

								- 通用寄存器

									- 保存变量和临时结果

								- 专门寄存器

									- 程序计数器 PC（或者IP）

										- 用来指向下一条指令的内存地址

									- 程序状态字 PSW
program status word

										- 条件码 condition code

											- 保存最近的算术或逻辑运算的状态信息

										- CPU优先级
										- 模式（内核态、用户态）

									- 堆栈指针

										- 存放栈顶地址

							- 按存储分类

								- 整数寄存器 register

									- 用来存储地址值或整数数据

								- 向量寄存器

									- 存放整数或浮点数

					- 时钟存储器：
存储单个位或者字，控制寄存器加载输入值
					- ALU 算术逻辑单元
arithmetic & logic units

						- 半加器 half adder 全加器 full adder
						- 8位行波进位加法器 8bit-ripple-carry-adder

					- Cache 高速缓存存储器
					- MMU 内存管理单元

				- 设备控制器

- 存储器单元

	- 存储器
（存储位级信息）

		- 分类

			- 内存==随机访问存储器 RAM
带有地址，存储字级数据

				- 分类

					- 寄存器文件
					- 处理器虚拟内存系统

						- SRAM 静态内存

							- 多路复用器 multiplexers

								- 门锁 gated latch

									- 寄存器 register

										- 锁存器 and-or lock
										- 数据输入线
										- 允许写入线
										- 允许读取线

								- 地址

						- DRAM
						- FRAM
						- Flash memory

			- 硬盘

### 计算机基本的逻辑结构

- 器件组成

	- 中央处理器 CPU

		- 机器指令-指令集

			- 指令集架构的分类

				- CISC

					- X86指令集

						- 特点

							- 向下兼容
							- 变长指令
							- 多种寻址模式

								- offset

						- 缺点

							- 资源利用率低

				- RISC

					- MIPS指令集

						- 特点

							- 尽量简化硬件指令设计

								- load/store指令外没有其他内存访问指令

							- 充分利用CPU的pipeline

						- 缺点

				- ARM指令集

			- 指令集架构的组成
ISA instruction0set architecture

				- 状态单元
				- 指令集和指令编码
				- 指令集编程规范
				- 异常事件处理

			- 指令集设计 Instruction

				- 指令设计

					- 支持的数据类型、寻址方式
					- 支持的指令类型

						- 数学指令/算术操作指令、内存指令/传送指令、控制指令/分支指令等等

					- 指令如何编码为字节序列

						- 可变指令长度？

				- 硬件逻辑设计

					- 逻辑运算和算术运算的硬件逻辑基础：
逻辑门、组合电路、存储器等等
					- 硬件控制语言
HCL  hardware control language
					- 实现同时适合不同类型指令的通用硬件框架

						- 控制寄存器文件和随机存储器
控制算术逻辑单元

		- 逻辑设计

			- 指令流水线

				- 顺序操作的处理器
				- 流水线化（pipelined）的处理器

					- 将处理组织为多个阶段

						- 阶段划分：
取指、译码、执行、访存、写回、更新PC
						- 硬件实现

					- 将多个处理组织为流水线

						- 流水线的局限性

							- 不一致的划分
							- 流水线过深，收益下降

						- 带反馈的流水线系统
						- 分支预测
						- 流水线冒险

							- 数据冒险
							- 控制冒险

						- 异常处理
						- 硬件实现

							- 划分处理阶段
							- 引进流水线
							- 添加更多的控制逻辑以满足分支预测、冒险等

			- 并发处理
			- 并行处理
多核处理器

	- 存储器 

		- 寄存器
————
高速缓存（L1 + L2）
————
主存 RAM | ROM | Flash Memory 
————
磁盘

	- I/O设备
（设备控制器和设备）
	- 主线 IO

		- 多种类型

## 机器层面 程序的结构与执行

### 信息的表示与处理

- 信息的表示和存储

	- 数字的进制

		- 二进制
		- 十六进制

			- 掩码

	- 表示数字
	- 表示字符
	- 表示代码

		- 不同机器上编译后的二进制代码是不同的

	- 运算

		- 位级运算

			- 二进制与布尔代数

				- C语言：& | ~ ^

		- 逻辑运算

			- C 语言：&& || ！

		- 移位运算

- 整数的表示和算术运算

	- 表示

		- 无符号数

			- 编码

		- 有符号数

			- 补码编码

		- 相互转换

			- C语言：隐式转换规则

		- 整数的扩展
		- 整数的截断

	- 运算

		- 加法

			- 无符号加法
			- 补码加法
			- 补码取非

				- 取反加一

		- 乘法

			- 无符号乘法
			- 补码乘法
			- 乘以常数
			- 除以2的幂

- 浮点数的表示和算术运算

	- 表示

		- IEEE浮点表示法
		- 舍入

	- 运算

### 程序的机器级表示
（汇编语言程序（AT&T语法格式)）
（不是机器代码/直接序列）

- 程序的机器级代码
（计算机如何抽象来隐藏细节，使程序运行）

	- 指令集架构 ISA

		- 使用AT&T

	- 内存地址使用虚拟地址

- 基础数据类型

	- 数据类型：字节

		- 大小：1字节
汇编代码后缀：b
C语言中数据类型：char
8位数

	- 数据类型：字

		- 大小：2字节
汇编代码后缀：w
C语言中数据类型：short
16位数

	- 数据类型：双字

		- 大小：4字节
汇编代码后缀：l
C语言中数据类型：int
32位数

	- 数据类型：四字

		- 大小：2字节
汇编代码后缀：q(qura的单字符表示)
C语言中数据类型：long 、char*（也就是地址）
64位数

- 数据的访问和操作

	- 操作数 operand

		- 1、立即数
		- 2、寄存器

			- 寄存器中存有不同字节长度的数

		- 3、内存数据引用

			- 从内存中取出数据
			- 寻址模式

				- 基址寻址

					- (%esp)
语义：将寄存器esp中记录的数据作为地址访问，取到地址中存的数据

				- 变址寻址

					- 类似C语言中的数组访问的规律

	- 数据的传送和访问指令

		- 32位指令集中，8个寄存器，当程序参数超过6个时，需要使用内存地址，需要栈的操作

			- 64位指令集中，16个寄存器，参数和数据的传递可以都通过寄存器来完成，更加高效

		- 用于在不同类型操作数之间复制数据，具有访存操作

			- MOV类

				- movb、movw、movl、movq

			- MOVZ类

				- 零扩展

			- MOVS类

				- 符号扩展

		- 执行地址值的计算并复制数据，无须访存

			- LEA类（&）

				- src（地址计算表达式）、dest
				- leal、leaq
				- 还可以用于整数计算

		- 在内存栈和寄存器间传输

			- pushq和popq

				- 用于将数据压入或弹出程序栈（传送的数据主要是地址）
				- 和存储栈顶元素地址的寄存器%rsp紧密相关

	- 算术操作指令、逻辑操作指令

		- 双操作数指令

			- addl、subl、imul、mul、idiv、div

				- 加减乘除

			- sall、sarl

				- 位移指令

			- xorl、andl、orl

				- 逻辑指令

		- 单操作数指令

			- incl、decl

				- 加一、减一

			- negl

				- 取相反数

			- notl

				- 逻辑指令

		- cltd 自动扩展符号位到8字节

- 控制
control

	- 条件码

		- 存储了算术运算和逻辑运算的状态

			- 有则为1，无则为0

		- 分类

			- CF carry flag
			- SF sign flag
			- ZF zero flag
			- OF overflow flag

	- 条件码设置指令，产生条件码的值

		- TEST类

			- test a , b（相当于a&b)

		- CMP类

			- cmpl b, a （相当于compare a - b) 

	- 条件码读取指令，读取条件码的组合，将结果存入寄存器

		- SET类

			- 特殊情况在于，为了充分利用CPU pipeline的特性，执行setl时，会将高位的32位零扩展，相当于setq

	- 条件跳转指令

		- 读取条件码的组合（跟在条件码设置指令后面），选择下一条执行语句的分支

			- JUMP类

	- 条件传送指令

		- 读取条件码的组合（跟在条件码设置指令后面），选择执行mov语句或跳过

			- CMOV类

	- 几种条件分支的实现
If-then-else、swith

		- 利用条件控制实现 | 利用条件传送实现

			- 尽量少用JUMP，减少不必要的计算损失
			- 适合条件传送的情况：两个分支都进行计算，再作选择
			- 不适合条件传送的情况：
1、某一分支计算量较大（应优先计算条件表达式）
2、计算某一分支时更改全局变量，影响另一分支的计算，有副作用

- 过程（函数）
predure

	- 程序调用栈/运行时栈
（用于实现过程中控制和数据的传递）

		- 压栈操作

			- pushl

		- 出栈操作

			- popl

		- 过程调用指令

			- call

				- 将下一条指令的地址作为返回地址压栈，在跳转到call指定地址

		- 过程返回指令

			- ret

				- 返回地址

	- 转移控制

		- 基于栈的编程语言

			- C，Pascal，Java

		- 过程调用

			- CALL指令 跳转到指定地址

				- 将返回地址push入栈

			- RET指令 跳转到返回地址

				- 返回地址由栈pop得到

			- 支持递归

				- 代码是可重入的（可有同一过程的多个实例在运行）
				- 每个过程实例的数据包括参数、局部变量、返回地址，需要有专门的一块区域来存储
				- 每个过程实例要单独维护自己的栈帧（stack frame）

	- 传递数据

		- 大部分通过寄存器传递

			- 传入值一般在 %rdi %rsi
			- 返回值一般存在 %rax

	- 数据的存储：
内存的分配和释放

	  %ebp  %esp

		- 进入过程后，先分配栈帧空间
“set-up" code
		- 寄存器中的局部存储空间

			- 程序运行时寄存器临时存储的约定

				- 调用者保存和恢复

					- %eax %edx %ecx

						- %eax用于保存被调用值的返回值

					- PUSH POP指令

				- 被调用者负责保存和恢复

					- %ebx %esi %edi
					- PUSH POP指令

				- 特殊用途

					- %ebp栈底 %esp栈顶

						- 采用以%ebp为基址的寻址过程
						- 定位 +4 +8 +12，存储
-4 -8 -12，存储临时指针

		- 过程调用中栈的局部存储
body code

			- 父过程栈帧中与当前过程相关内容
位于栈底之下

				- 当前过程的输入参数
				- 返回地址：call指令下一条指令的地址

			- 当前栈帧内容自底向顶有

				- return address
				- 父过程的栈帧起始地址（old %ebp）

					- %ebp或者%rbp

				- 被保存的寄存器值saved registers（依照惯例调用者和被调用者各自将负责的寄存器的值存起来，用于过程结束后的恢复）
				- 局部变量 local variables（寄存器个数有限，多出的部分存在这里）
				- 子过程参数 arg build

					- %rsp或者%esp

		- 过程返回时，释放空间
”finish“ code

- 数据结构
datastruct
（基础数据类型+指令）

	- 各种数据结构如何实现？如何实现的内存分配和访问

		- 内存越界引用和缓存区溢出

	- 数组 array 
研究一下存储布局（memory layout）

		- 数组的内存和存储

			- C语言：数组访问 
每一元素的内存等于单位数据结构的空间内存，连续存储

				- 无边界检查

			- 实现方法

				- 数组循环：%eax存放局部变量（i、j）等，%edx存放数组的起始地址
				- 指针循环：%eax存放数据结构（指针）长度 * i，%edx存放数组的起始地址

			- 定长数组与变长数组（变长：数组大小暂时用变量表示）

		- 嵌套数组
nested array

			- 在内存中连续存储
			- 访问嵌套数组中的”行“

				- 利用leal指令来访问
leal array(, %eas, 4), %eax

		- 多层数组
multi-level array
比如指针数组

			- 在内存中，同层之间是没有连续存储关系的
			- 两次访存
			- 举例 n * n 的二维数组

				- 静态参数  数组维度已知，用leal指令即可
				- 动态 数组维度运行时才知道，作为参数传入，使用imull指令

	- 结构 struct

		- 每个元素在结构中的相对地址在编译时在编译阶段确定

			- 机器码中不再具有字段名字的信息

		- 连续分配的内存区域，各元素通过名字访问，各元素的数据类型可以是不同的

	- 联合 union

		- 成员共享一块内存，一次只能使用其中的一个成员

	- 数据对齐

		- 基本数据类型:已知某种基本数据类型大小为K字节，存储地址必须是K的整数倍，访问比较高效，不会引起额外的内存访问

			- 32位系统数据对齐举例：
char无要求；short要求2字节对齐，地址最后一位为0；int/float/char*，要求4字节对齐，地址最后两位为0；double，8字节对齐，地址最后3位为0

		- 结构 struct

			- 1、满足元素对齐要求
2、自身对齐要求等同于各元素对齐要求
3、起始地址和结构长度必须是对齐要求最高的数据类型的整数倍
			- 因此，struct设计的时候，合理地组织元素顺序可以更好地组织存储空间，节省空间

		- 联合 union

			- 以最大存储空间要求的元素为准

- 控制和数据的交互

	- 汇编程序结构

		- 整体观察：注意如何建立栈帧、引入变量、引入常量、引入函数

			- movl $参数地址，(%esp)

		- 汇编指示derectives 以“.”符号开头

			- .file  .def 用于调试
			- 类型说明
.ascii  文本字符串
.float 浮点数
			- 以“:”结尾字符串，用以表示变量/函数地址的符号

				- 举例：
				- .p2align 4,,15  #按照2的4次方对齐，允许额外填充15字节
				- .section .rdata, "dr" #其中的数据是只读数据段

		- 主要结构

			- helloworld.o 示例代码

			  .data
			    #数据段
			  msg:
			          .ascii "hello \n"
			         len = . - msg        #“."表示当前数据
			  .text  #代码段
			  .global _start  #汇编程序入口，_main函数
			  _start:
			  		movl $len, %edx
			  		...  #若干命令

			- .text  正文段 程序指令，汇编程序必须包含此段
			- .data 数据段  声明带有初始值的元素
			- .bss  数据段  声明无须初始化的元素

				- 不会预先就划分空间，仅在程序运行以后才划分
				- .comm 未初始化的全局内存区域
				- ,lcomm  未初始化的本地内存区域

		- C程序的内存布局

			- [stack]     自顶向底


Heap       动态分配的部分，自底向顶
[data]      数据段，静态声明的部分
[text]       文本段

	- 汇编命令
（linux）

		- as - o my-object-file.o helloworld.s --32
	
			- assembled
	
		- ld -0 my-exe-file my2-objectfile.o
	
			- 多个.o文件
	
	- 过程调用
	
		- 代码示例
幂函数和计算

		  .section .text
		  ,globl _start
		  _start:
		  	pushl $3
		  	pushl $2
		  	call power
		  	addl $8,%esp
		  	pushl %eax
		  
		  	pushl $2
		  	pushl $5
		  	call power
		  	addl $8, %esp
		  	popl %ebx
		  
		  	addl %eax, %ebx
		  	movl $1, %eax  #exit
		  	int $0x80
		  
		  .type power, @function
		  power:
		  	pushl %ebp  #保存原有pointer
		  	movl %esp, %ebp
		  	subl $4, %esp
		  	movl 8(%ebp）， %ebx  #参数1 传入%ebx
		  	movl12(%ebp), %ecx
		  	movl %ebx, -4(%ebp)
		  
		  power_loop_start:
		  	cmp $1, %ecx
		  	je end_power
		   	movl -4(%ebp), %eax
		  	imull %ebx, %eax
		  	movl %eax, -4(%ebp)
		  	decl %ecx
		  	jmp power_loop_start
		  
		  end_power:
		  	movl -4(%ebp),%eax  #return value goes in %eax
		  	movl %ebp, %esp
		  	popl %ebp  #restore the base pointer
		  
		  	ret
	
		- 递归调用
	
			- 代码示例
阶乘 factorial.s

		- 示例：文件处理中的过程调用
	
			- 代码示例
	
				- .equ  把常量设置为Symbol
.equ LINUX_SYS_CALL, 080
.equ SYS_OPEN, 5

	- 系统调用
（x86-Linux ）

	  #什么是系统调用？
	  
	  Linux内核中设置了一组用于实现各种系统功能的子程序，称为系统调用。用户可以通过系统调用命令在自己的应用程序中调用它们。从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态；而普通的函数调用由函数库或用户自己提供，运行于用户态。二者在使用方式上也有相似之处，在下面将会提到。
	  
	  随Linux核心还提供了一些C语言函数库，这些库对系统调用进行了一些包装和扩展，因为这些库函数与系统调用的关系非常紧密，所以习惯上把这些函数也称为系统调用。


​	  
	  #系统调用是怎么工作的？
	  
	  一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作"保护模式"）。系统调用是这些规则的一个例外。其原理是进程先用适当的值填充寄存器，然后调用一个特殊的指令，这个指令会跳到一个事先定义的内核中的一个位置（当然，这个位置是用户进程可读但是不可写的）。在Intel CPU中，这个由中断0x80实现。硬件知道一旦你跳到这个位置，你就不是在限制模式下运行的用户，而是作为操作系统的内核--所以你就可以为所欲为。
	  
	  进程可以跳转到的内核位置叫做sysem_call。这个过程检查系统调用号，这个号码告诉内核进程请求哪种服务。然后，它查看系统调用表(sys_call_table)找到所调用的内核函数入口地址。接着，就调用函数，等返回后，做一些系统检查，最后返回到进程（或到其他进程，如果这个进程时间用尽）。如果你希望读这段代码，它在<内核源码目录>/kernel/entry.S，Entry(system_call)的下一行。
	
		- 通过中断指令（int 0x80）来实现
和%eax、%ebx紧密相关

			- 通过寄存器来传参，而不是像过程调用中以栈来传参
			- 常见命令
	
				- exit
				- fork
				- read
				- close
				- waitpid
				- creat
				- unlink
				- execve
				- chdir
	
		- 代码示例
	
		  .data
		  msg:
		  	.ascii "hello"
		  	len = . - msg
		  
		  .text
		  .globl _start
		  _start:
		  	movl $,%edx
		  	movl $msg, %ecx
		  	movl $1, %ebx  #告诉系统要写到1号输出(write 系统调用）
		  	movl $4,%eax
		  	int $0x80
		  
		  	movl $0, %ebx  #程序退出
		  	movl $1, %eax
	
		- lib_c库函数调用示例
	
			- 通过库函数展开，int0x80，可以进入系统内核

- 更复杂的部分：浮点代码

### 程序的机器级优化
（区别于算法级优化）
（编码级优化+并行计算优化）

- 算法级优化：

	- 使用适当的算法和数据结构，取得渐进意义上的优化

- 程序性能的度量：

	- CPE 大体估量了执行程序的周期数

- 实现优化的硬件原理

	- 处理器体系架构

		- 流水线通用原理

	- 存储器层次结构

		- 高速缓存

- 编码优化

	- 基本编码原则：
清楚编译器自动进行优化的局限性
避免限制编译器优化的因素

		- 典型的局限性

			- 不能肯定两个指针（内存别名）是否指向同一位置
			- 不能肯定函数调用（函数指针）是否对全局变量有影响

		- 消除连续的函数调用
		- 消除不必要的内存引用，引入临时变量来保存中间结果

	- 机器级优化

		- 展开循环，降低循环中重复操作的开销。
		- （基于流水线的实现原理、汇编层面高速缓存速度慢的原理）通过使用例如避免寄存器溢出、使用多个累积变量和重新结合变换等技术，缩短”关键路径“，找到方法提高指令级并行技术。
		- （基于流水线的条件预测原理）用功能性的分割重写条件操作， 使得编译采用条件数据传送。

- 并行计算优化

## 系统层面 程序的运行
（具体看操作系统部分，或Java虚拟机部分）

### 程序链接？？？

- 代码示例

## 程序间的交互和通信

*XMind: ZEN - Trial Version*