所有多线程编程样例代码的实现参考了[图解Java多线程设计模式](https://book.douban.com/subject/27116724/)中对多线程和并发编程设计模式的分类

先对业务进行抽象，根据抽象的结果选择合适的多线程模型来构造任务执行的顺序模型，选用编程语言（比如Java）提供的逐渐来具体实现。

> 第1章　　Single Threaded Execution模式——能通过这座桥的只有一个人
>
> 第2章　　Immutable模式——想破坏也破坏不了
>
> 第3章　　Guarded Suspension模式——等我准备好哦　
>
> 第4章　　Balking模式——不需要就算了
>
> 第5章　　Producer-Consumer模式——我来做，你来用
>
> 第6章　　Read-Write Lock模式——大家一起读没问题，但读的时候不要写哦
>
> 第7章　　Thread-Per-Message模式——这项工作就交给你了
>
> 第8章　　Worker Thread模式——工作没来就一直等，工作来了就干活
>
> 第9章　　Future模式——先给您提货单
>
> 第10章　　Two-Phase Termination模式——先收拾房间再睡觉　
>
> 第11章　　Thread-Specific Storage模式——一个线程一个储物柜
>
> 第12章　　Active Object模式——接收异步消息的主动对象

### 补充，操作系统里和多线程可能有关的一些知识

#### 操作系统的进程通信机制

从操作系统的层面看，进程之间有多种通信方法，主要分成消息传递和共享内存两类。即基于进程通信 IPC，可以使多个进程相互协作完成大的任务。进程通信是进程进行通信和同步的机制（见操作系统笔记）

1. 一类是间接通信，通过操作系统内核来通信。消息传递在linux中又有管道（有名管道、匿名管道）和消息队列两种具体实现
2. 一种是直接通信，通过共享信道来通信。共享内存方法，需要显示地使用文件描述符来获得文件，以文件作为共享信道。

#### 操作系统的进程/线程同步机制

<img src="C:\Users\Jinzhen\Documents\GitHub\CSmarch\jpg\3 计算机系统\操作系统同步方法.png" alt="操作系统同步方法" style="zoom:50%;" />

以下全是从共享内存的通信机制出发，实现进程/线程间的同步。

进程和线程关注代码中访问共享内存区域的程序段，为避免竞争条件race condition，采用互斥：确保一个进程正在使用一个共享变量或者文件的时候，其他进程不能做同样的操作。执行读写信号量的代码段就是临界区(critical section)。为了形成保护效果，要在临界区的前后设计进入区和退出区的代码，形成一种上锁的效果。上锁，这种在进程层面不可继续分解的操作称为原子操作。为了实现临界区的**互斥访问**，有3种解决方案。

1. 硬件解法：
   1. 硬件禁用中断，局限：仅限于单处理器可使用。
2. 软件解法，
   1. peterson算法，while循环+共享变量。局限：实现复杂，应用有限。
3. 原子操作指令法
4. 高级抽象的同步方法
   1. 自旋锁 spinLock
   2. 信号量 semaphore
      1. 二进制信号量 == 互斥锁 mutex lock
      2. 资源信号量
   3. 管程（临界区+多个条件变量），有些编程语言实现了“管程”的特性，从编译器的层面保证了临界区的互斥，比如Java的synchronized关键字。是一种语言概念，c语言不支持，java支持，只要将synchronized加入到方法申明中即可。
      1. 重要特性：任意时刻管程中只能有一个活跃进程。
      2. 管程是编程语言的一部分，由编译器来负责进入管程的互斥。编程人员无需知道编译器是怎样实现互斥的。一般是使用一个互斥量或二元信号量。以及使用条件变量来使进程在无法运行的时候被阻塞。

总结一下，在硬件层面，CPU提供了原子操作、关中断、锁内存总线的机制；OS基于这几个CPU硬件机制，或者软件解法，就能够实现锁；再基于锁，就能够实现各种各样的同步机制（信号量、消息、Barrier等等等等）。

从操作系统的层面看，线程之间也有多种同步方法

### 编程语言（Java）提供的进行多线程编程的基础组件

具体底层原理见其他笔记，这里阐述一下理解





