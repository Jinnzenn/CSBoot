# 3.3.2 分布式系统 （distributed system）

参考：https://waylau.gitbooks.io/distributed-java/docs/basic.html

参考：《分布式系统概念和设计》

## 什么是分布式系统？

### 分布式系统为何产生？

- 初衷：任务需求过大，单机系统无法解决时，可以提高单机系统的性能，或者扩展系统，利用集群多机的能力。分布式系统就是试图解决单机系统无法解决的计算和存储问题。

### 分布式系统的定义和模型？

- 定义

  - 具体如何仍然需要长期的观察、总结和实践

  - 《分布式系统原理与范型》一书的定义：
    分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像是单个相关系统。
    硬件独立：计算机机器本身是独立的
    软件统一：对于用户来说，他们就像是跟单个系统打交道

  	- 分布式系统的系统特性：
  内聚性：子系统之间仅仅通过网络连接交换数据，子系统内部独立完成大量计算机任务。
  透明性：用户和应用程序交互时，不会察觉哪些部分正在替换或者维修，也不会感知到新部分的加入。

  - 维基百科对“分布式系统”的宏观定义：

    分布式系统是一种其组件位于不同的联网计算机上的系统，然后通过互相传递消息来进行通信和协调。为了达到共同的目标，这些组件会相互作用。
    
  - 其他定义：分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。

- 分布式系统模型

  - 物理模型
  - 体系结构模型
    - 通信实体（进程 == 对象 / 组件 / 服务） + 通信范型（基于IPC socket的远程方法调用 RMI /  基于IPC socket的远程过程调用 RPC / 基于中间件的间接通信（组通信( 发布订阅系统 / 消息队列 ) | 分布式共享内存 DSM））  + 通信中实体的关系（从角色和责任看，分为客户端/服务器 和 P2P 两种类型）
    - 体系结构模式：应用/服务--中间件--平台（操作系统--计算机硬件和网络硬件）
      - 两层解决方案，在WebAPP开发上体现为 model1 + model2
      - 三层解决方案，在WebAPP开发上体现为 MVC
      - 代理模式
      - 等等
  - 基础模型。分布式系统需要解决的共性问题
    - 交互模型
      - 受限进程之间通信不可靠的问题、进而受限进程之间没有同一的时钟，
      - 进程难以同步的问题
    - 故障模型，如何应对系统内部交互出错的情况？
      - 遗漏故障：进程遗漏故障和网络遗漏故障
      - 随机故障
      - 时序故障（同步类型的分布式系统特有的）
      - 以上几种故障的检测手段和修复方法
    - 安全模型，如何防范系统外部的攻击？
      - 保护对象，保护进程和进程交互过程（也就是通信过程）
      - 威胁
        - 对进程的威胁
          - 客户机
          - 服务器
            - 比如洪泛攻击，要采用拒绝服务的方法解决
            - 比如移动代码，典型的就是SQL注入
        - 对通信通道的威胁
          - 中间人攻击，伪造消息。HTTP-HTTPS
      - 安全手段
        - 密码学，加密与解密
          - 权限认证
        - 安全信道

### 分布式系统的类别

- 数据存储，计算，文件系统，邮件系统，分类帐，应用程序

### 性能指标：
吞吐量、并发数、响应延迟

### 非性能特征：

可靠性、可拓展性、一致性，每一方面都要通过多种技术手段来改进

- 可用性

	- 系统在面对各种异常时可以正确提供服务的能力。分布式系统某些节点故障，不影响整体的可用性。好的分布式系统，系统停服务的时间与正常服务的时间的比例应是尽量低的。

- 可拓展性

	- 分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力。好的分布式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长。

- 一致性

	- 分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。一致性衡量了系统应对此问题的能力。越是强的一致的性模型，对于用户使用来说使用起来越简单，数据更新后可以立刻读到最新的修改。

## 分布式系统的实现原理

### 分布式系统的交互模型（实现进程之间的通信和同步）

- 解决分布式算法的问题。区别于严格顺序执行的单机上的算法，分布式算法的执行步骤并非严格按照顺序。
- 分布式系统的影响进程交互的主要方面：通信信道的性能问题 和 通信延迟带来的计算机时钟问题。这两个问题不明确解决，节点间的同步也就无从谈起。
- 分布式系统进程交互的行为
  - 多播multicast

#### 通信信道的性能。不同节点上的通信实体需要通过消息传递完成任务，怎么保证通信过程是可靠的。解决这个问题的关键是设计可靠的网络协议。

- 不管采用哪种通信范型（RMI | RPC | 间接通信），通信时间都不能保证（网络延迟和网络带宽会变化）
  - communication channel 的固有缺陷
    - 延迟（延迟包括单机发送/接受消息的延迟 + 消息进入网络的延迟 + 消息在网络中传输的延迟 + 消息在路由系统中排队的延迟等等）
    - 带宽，网络拥塞情况可能不断变化
    - 抖动 jitter

#### 计算机时钟和时序事件。计算机不同节点上的时钟不能完全同步一致，怎么确定事件的先后顺序。解决这个问题的关键是**逻辑事件模型**。

- 产生原因
  - 每个单机内置时钟不同
  - 单机上的进程 Local clock of different processes show different time values  
  - Clocks drift from perfect times at different rates  
- 分布式系统和物理时钟的同步。1、系统和外部UTC事件源的外部同步 2、系统内各线程之间的内部同步
  - 外部同步，两个进程之间如何同步时间？比如客户端和服务器。
    - Tc = (Ts + (min + max)/2), skew(client,server) ≤ (max – min)/2  。最优方法。
  - 内部同步，同步时钟的算法
    - Cristian Algorithm 用于企业内网
      - 有时钟服务器和外界时钟源进行外部同步。然后内部其他客户端和时钟服务器同步。
      - Tc = Ts + (Tround / 2) ， skew ≤ (Tround / 2) – min (min is minimum one way network delay)  
      - 缺点：中心化的时钟服务器如果故障，整个系统时间都不准。
    - Berkeley Algorithm 用于企业内网
      - 由一个服务器轮循其他节点，统计所有节点时间取平均值，再返回offset给所有节点
    -  Network Time Protocol 用于因特网整体时间同步，比较复杂
      - 对称模式 
- 逻辑时间和逻辑时钟
  - 对于单一进程，推理时间发生的逻辑顺序较为简单。eij is the jth event of the ith process.
    - history(pi) = hi = < ei0, ei1, ei1, …. eim >  
    - happen before先行发生 Happened-before (HB)  
      - 单一进程内 If ∃ pi , e →i e’ then e → e’.
      - 多进程之间，For any message m, send(m) → receive(m)
      - 传递性 If e → e’ and e’ → e” then e → e  
  - 但由于在一个分布式系统中不能完美地同步时钟，所以不能在物理时间上确定event发生的顺序，只能从逻辑上推定。能够从逻辑上推定event发生顺序，才能协调进程对共享资源访问的顺序，进行进程同步。![事件时钟](C:\Users\Jinzhen\Documents\GitHub\CSmarch\jpg\3 计算机系统\事件时钟.png)
    - lamport logic clock  逻辑时钟；缺点，从L(e) < L(e')，不能推出 e -> e'
    - **vector logic clock 向量逻辑时钟**； 克服了lamport的缺点，但相比lamport占用存储较多，信息的有效载荷和进程数成正比。
    - How to compare timestamps across different processes?
      • Physical timestamp: requires clock synchronization.
      • Google’s Spanner Distributed Database uses “TrueTime”.
      • Lamport’s timestamps: cannot fully differentiate between causal and concurrent ordering of events.
      • Oracle uses “System Change Numbers” based on Lamport’s clock.
      • Vector timestamps: larger message sizes.
      • Amazon’s DynamoDB uses vector clocks.  
- 全局状态和一致割集。全局性时钟，
  - State of a process (or a channel) gets transformed when an event occurs. 3 types of events: local computation, sending a message, receiving a message.  
  - Useful to capture a global snapshot of the system:
    • Checkpointing the system state. //查看分布式系统全局状态
    • Reasoning about unreferenced objects (for garbage collection).//查看对象引用关系
    • Deadlock detection.//死锁检测
    • Distributed debugging  //分布式系统的调试
  - 使用一些算法记录下所有进程的状态的集合
    - Chandy Lamport Algorithm 算法是一个采用分布式快照算法来解决记录分布式全局状态一致的算法。[这个算法的核心，就是创造出一个maker来记录整个分布式链的状态，当链上的节点出现异常需要恢复的时候就根据当前状态找到之前的maker，然后重新计算，保证分布式状态一致。](https://www.cnblogs.com/yuanyifei1/p/10360465.html)，Apache Flink基于此算法改进。关键要理解 **不一致的全局状态**和 **一致的全局状态**。一致的全局状态snapshot之间可以形成一个网络，网络中的每一条快照组成的路径都是线性一致性的。
    - 基于全局状态snapshot之间有可达路径，可以用来作为system properties的分析（global state predicates）。推测的规则图示见PPT
      - Stable = once true, stays true forever afterwards  。
      - Liveness = guarantee that something good will happen, eventually 。避免死锁、活锁
      - Safety = guarantee that something bad will never happen.  

- 推论：分布式系统只能做成异步式的，如果是同步的，需要
  - Known upper and lower bounds on time taken by each step in a process.
  - Known bounds on message passing delays.
  - Known bounds on clock drift rates.  

#### 组播/组通信，多个节点之间的消息传递的通信模型，重点是实现组播的Gossip算法。逻辑事件模型假设了消息传递是完全有序的，要推定事件之间的逻辑顺序，就要能够控制消息在节点之间到达的顺序。解决这个问题的关键就是实现组播的有序性的几种算法（ISIS等等）

- 通信实体（进程 == 对象 / 组件 / 服务） + 通信范型（就具体实现和通信实体分类，基于IPC socket的通信实体为对象的远程方法调用 RMI /  基于IPC socket的通信实体为服务的远程过程调用 RPC / 通信实体为中间件的间接通信（组通信multicast( 发布订阅系统 / 消息队列 ) | 分布式共享内存 DSM））  + 通信中实体的关系（从角色和责任看，分为客户端/服务器 和 P2P 两种类型）
  - Communication modes **通信范型**
    - Unicast. Messages are sent from exactly one process to one process.
    - Broadcast. Messages are sent from exactly one process to all processes on the network.
    - **Multicast. Messages broadcast within a group of processes. A multicast message is sent from any one process to the group of processes on the network.**  
      - Distributed storage
        • Write to an object are multicast across replica servers.
        • Membership information (e.g., heartbeats) is multicast across all servers in cluster.
      -  Online scoreboards (ESPN, French Open, FIFA World Cup)
        • Multicast to group of clients interested in the scores.
      -  Stock Exchanges
        • Group is the set of broker computers  
- 组通信 Multicast 的基本分类
  - 基本组播 basic multicast，use a reliable one-to-one send (unicast) operation:  
  - 可靠组播 reliable multicast  进一步地保证message可靠性，但未保证有序
    - 完整性、有效性和协定的可靠性
  - 有序组播 ordered multicast 进一步地保证message有序性(图示见PPT)。其实就是如何标识各个消息实现消息顺序。
    1. 可靠的FIFO Order  ， 只保证从单个的消息sender看来，自己发送的消息是有序的到达每个receiver。多个sender到达同一receiver的顺序不要求。
       1. 实现算法：如果后发的消息先到，该消息会先buffered
    2. 可靠的Causal Order  ，进一步的，如果多个sender的多个消息之间有因果关系，需要保证这几个消息有序到达同一receiver。多个sender之间没有因果关系的message不要求到达顺序。
       1. 实现算法：
       2. 上述两种，Causal Order隐含了FIFO
    3. 可靠的Total Order，所有sender发出的消息，按发出时间的顺序有序到达所有的receiver.
       1. 实现算法：ISIS
       2. FIFO-total hybrid protocol satisfies both FIFO and total orders.
       3. Causal-total hybrid protocol satisfies both Causal and total orders  
       4. 既保证可靠传递，又保证全排序传递的算法，只有在同步的分布式系统中是可能的，在异步的分布式系统中是不可能的。
- 组通信下，如何具体实施一对多通信
  - B-Multicast using unicast sends  B-Multicast using unicast sends  
  - Tree-based multicast ，也就是 IP multicast ；Instead of sending a unicast to all nodes, construct a minimum spanning tree and unicast along that  
  - Gossip  ;No “tree-construction” overhead. More efficient than unicasting to all receivers. Also known as “epidemic multicast”.  
    - Facebook’s distributed datastore uses it to determine group membership and failures.
    - Bitcoin uses it to exchange transaction information between nodes (more later).  
  - 组通信下，如何解决共识问题
- 组通信算法，可以经由远程调用（RPC | RMI )或者间接通信（pub/sub、MQ）来具体实施
- 

#### 进程之间的协调。进程之间协调最关键的是对共享资源的互斥访问，以实现进程同步（多个线程按照逻辑顺序访问共享资源）。保证消息传递message可靠有序和事件顺序event可确定之后，才有可能协调不同节点上进程的关系，解决这个问题的关键就是RA算法。

- 单机系统下的互斥操作 Mutual exclusion for a single OS ，思路，创造临界区
  • If all processes are running in one OS on a machine(or VM):
  	•信号量 Semaphores
  	•互斥锁 Mutexes
  	•条件变量 Condition variables
  	•监视器锁/管程 Monitors
  	• … 
- 分布式系统下的互斥操作 Mutual exclusion in distributed systems  
  - 只能通过消息传递来实现Processes communicating by passing messages.不能通过共享变量来实现Cannot share variables like semaphores! 如何实现？How do we support mutual exclusion in a distributed system?   
- 分布式系统的互斥算法
  - 互斥算法的非性能特征
    - Safety (essential):• At most one process executes in CS (Critical Section) at any time.
    - Liveness (essential): Every request for a CS is granted eventually.
    - Ordering (desirable): Requests are granted in the order they were made  
    - 容错性，消息丢失时发生什么？进程崩溃时发生什么？
  - 互斥算法的性能指标Analyzing Performance  
    - Bandwidth: the total number of messages sent in each enter and exit operation.
    - Client delay: the delay incurred by a process at each enter and exit operation (when no other process is in, or waiting)
      • We will focus on the client delay for the enter operation.
    -  Synchronization delay: the time interval between one process exiting the critical section and the next process entering it (when there is only one process waiting). Measure of the throughput of the system  
  - Central server algorithm
    - 算法：Master持有token bucket，管理其他服务器发来的request 组成的queue。
    - 非性能特征：有序性上，看中央服务器接收到request的顺序。
    - 性能：带宽（中央服务器和客户端之间传输令牌），客户端请求延迟（发起令牌请求到获得令牌），客户端之间的同步延迟（客户端A返还令牌给中央服务器，中央服务器分配令牌给客户端B）
    - 缺点： master成为性能瓶颈The master is the performance bottleneck and 和不能避免单点故障single point of failure  ，单点故障可能时中央服务器崩溃，或者持有token的服务器崩溃
  - Ring-based algorithm
    - 算法：只有一个token，所有服务器组成ring，轮流持有
    - 非性能特征：并非有序。
    - 性能：token时钟在环上传递，持续消耗带宽。
    - 缺点：不能容忍环上任何一个服务器的崩溃
  - Ricart-Agrawala Algorithm
    - 算法：无token，通过因果关系的组播实现互斥访问。进入临界区需要其他进程的应答，同时发起请求时，由事件的逻辑顺序来确定顺序。
    - 非性能特征：有序。不能容忍节点崩溃
    - 性能：
    - 缺点：
  - Maekawa Algorithm  
    - 算法：在RA算法上改进，不用获得所有进程的应答，而是获得对等进程组的应答。所有进程组两两之间都有交集。
    - 非性能特征：有序。可以容忍不相关的进程组的崩溃
    - 性能：
    - 缺点：
- 分布式系统的选举算法
- 

#### 实现事务操作。能够实现进程的互斥操作之后，才有可能实现事务性。

### 分布式系统的故障模型（检测进程之间的通信问题和同步问题）

- 故障问题有哪些
  - 遗漏故障
    - 进程遗漏故障。进程崩溃 fail
      - 进程故障的故障检测器，利用超时来检测。 ping+ack 或者 心跳检测heartbeat
        - 关键是要完全和准确。完全，每个进程故障都能被捕捉到。准确，不能在故障没有发生时就认为故障发生。
      - 以下为两个进程之间的检测过程。
      - Ping-ack ，需要在网络中发送 2 messages every T units  
        - 如何量化判断两个进程之间出现故障？求超时时间∆1 如何设置
          - 同步的分布式系统 synchronous。单次ping-ack就行, ∆1 = 2(max network delay)  ，超过2x网络最大延迟，没有收到ack，进程故障
          - 异步的分布式系统 asynchronous。参考观察到的最大值  ∆1 = k(max observed round trip time)  ，**只能估计。**
        - 最坏情况下，从故障出现，到故障发现，间隔多久？（具体见UIUC 的slide)
          - 不管是同步还是异步，假设∆是上一次ping发出和ack返回间隔的时间，t + T +∆ 1 - ( t + ∆ ) = T + ∆1-  ∆	  
      - heart-beat，需要在网络中发送 1 message every T units.  
        - 如何量化判断两个进程之间出现故障？求超时时间∆2如何设置
          - synchronous,  每隔T发送一次heartbeat, 最坏情况下，两次接收的间隔是
            - ( t + T  + max network delay）- ( t + min network delay ) = T + ∆2 
            - ∆2 = max-min
          - asynchronous, ∆1 = k(max observed round trip time)  ，**只能估计。**
        - 最坏情况下，从故障出现，到故障发现，间隔多久？
          - ∆ + T + ∆2   
          - 具体而言，异步可能比同步久得多，因为异步执行，无法知道对方什么时候可以执行结束。
        - 问题来了，heartbeat 如何扩展到多个？？？
        - How do we extend to a system with multiple processes?
          - Centralized heartbeating: not complete. 
            - 缺点：不能克服中心节点可能失效的问题，中心节点的单点故障不能检测
          - Ring heartbeating: not entirely complete. 
            - 缺点：不能克服多点失效的问题 Multiple failures ，多点失效时，无法判断环上是哪几个节点失效 Ring repair overhead
          - All-to-all: complete, but more bandwidth usage.  
            - 缺点：带宽耗费高
            - 改进：每个节点，根据和其他节点的延迟[min, max]，选择能最快发现自己故障的节点发送心跳。
      - trade-off
        - 缩短检测周期，将会增加网络带宽的消耗。Decreasing T decreases failure detection time, but increases bandwidth usage.  
        - 增加超时时间，减少了检测出错的可能，但也增加了故障发生到发现故障的时间差。Increasing ∆1 or ∆2 increases accuracy but also increases failure detection time.  
    - 通信遗漏故障。通信信道communication channel 出错
      - 通信故障，采用网络协议来补偿。Message drops (or omissions) can be mitigated by network protocols  
  - 随机故障（拜占庭故障），最为严重的一种
  - 时序故障，同步分布式系统会出现的故障。
- 故障屏蔽，将随机故障转化为遗漏故障

### 分布式系统的安全模型

- 保护对象，保护进程和进程交互过程（也就是通信过程）
- 威胁
  - 对进程的威胁
    - 客户机
    - 服务器
      - 比如洪泛攻击，要采用拒绝服务的方法解决
      - 比如移动代码，典型的就是SQL注入
  - 对通信通道的威胁
    - 中间人攻击，伪造消息。HTTP-HTTPS
- 安全手段
  - 密码学，加密与解密
    - 权限认证
  - 安全信道

### CAP理论 - 一致性/可用性权衡

### 

## 如何设计一个分布式系统？

### 首先，这个分布式系统是一个什么类型的分布式系统？数据存储，计算，文件系统，邮件系统，分类帐还是应用程序？

- 数据存储：分布式数据库、分布式缓存
  - 分布式数据系统大概的模型
    - 节点，一个可以独立按照分布式协议完成一组逻辑的程序个体。在具体的工程项目中，一个
      节点往往是一个操作系统上的进程。
    - 节点之间的通信
    - 存储

      - 数据分布

        - 数据分布方式

      - 数据副本

        - 数据副本协议

    - 计算

      - 本地化计算
- 计算：分布式计算系统
- 文件系统：分布式文件系统
- 应用程序：分布式软件系统

### 如何实现分布式存储和计算？

###     系统如何拆分为子系统？

###     如何规划子系统间的通信？

-     MQ 框架标准化了不同应用程序间非实时异步通信的方式。
-     RPC 框架标准化了不同应用程序间实时通讯的方式。
-     DAL（Data Access Layer，数据访问层）框架标准化了应用程序和数据库之间通讯的方式。

###     如何让子系统可以扩展？

###     子系统的可靠性如何保证？

###     通信过程中的安全如何考虑？

###     数据的一致性是如何实现的？

- 分布式存储

	- 数据库分库分表问题
	- 分布式存储中的
数据检索问题
	- 分布式缓存
	- Dubbo
	- ZooKeeper

- 分布式计算

*XMind: ZEN - Trial Version*