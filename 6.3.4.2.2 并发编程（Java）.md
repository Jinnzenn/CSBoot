# 6.2.2 并发编程（Java）

## 基础概念

### 并发
concurrency

- 并发现象：计算机系统的各个层面上都存在。多个逻辑控制流在时间上重叠，称作并发现象。
系统级并发：一种操作系统内核用来同时运行多个应用程序的机制。（这里自单个处理器）
应用级并发：一种应用程序通过逻辑控制流同时执行多项任务的机制。

	- 系统级并发：
操作系统中，一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行，但任一个时刻点上只有一个程序在处理机上运行。
	- 并行：当系统有一个以上处理器时,则线程的操作有可能非并发。比如当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

- 并发程序
concurrent program

	- 定义：
使用应用级并发的应用程序

		- 串行编程模型和并行编程模型

	- 构造并发程序的方法

		- 基于进程的
		- 基于I/O多路复用的
		- 基于线程的

## 基于进程的并发编程

## 基于I/O多路复用的并发编程

## 基于线程的并发编程
（在多处理器系统上有优势）

### 基础概念

- 同步和异步的概念

	- 同步与异步主要是从【消息通知机制】上发展出的概念。
同步的概念：就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。
同步的实现：体现在数据的访问上就是，在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。
	- 异步：异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。
异步的实现：在调用者和执行组件之间要能返回消息（执行结果），执行部件和调用者通过三种途径返回结果：状态、通知和回调。使用哪一种通知机制，依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。

- 阻塞调用和非阻塞调用的概念

	- 阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。

- 线程协作的四种方式

	- 同步阻塞
	- 异步阻塞
	- 同步非阻塞
	- 异步非阻塞

### 操作系统层面的并发编程（C语言）

- 线程执行模型

	- 主线程 main thread
	- 对等线程 peer thread
	- 线程的状态

		- 创建
		- 运行
		- 终止

- 线程内存模型

	- 程序代码的变量如何映射到内存？
	- 哪些是共享变量？
	- 物理机的内存模型

		- 物理机内存模型的设计目标：
定义内存使用规则，协调并发问题和计算机性能利用问题

			- 并发问题常存在于服务器，衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second,TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。 对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。

		- 内存模型：主内存+高速缓存Cache
（为了协调IO操作和处理器计算速度的差异，硬件上引入了高速缓存）

			- 缓存一致性协议Cache Coherence
（为了协调多个处理器各自的高速缓存和主内存的一致性的问题，物理机对缓存和内存的访问遵循某种缓存一致性协议，比如MSI、 MESI（Illinois Protocol）、 MOSI、 Synapse、 Firefly及Dragon Protocol等）

		- 乱序执行优化Out-Of-Order Execution
处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致

- 几种并发问题的解决

	- 并行性
多CPU的计算机系统，如何充分利用计算资源？

### JVM虚拟机层面的并发编程

- Java虚拟机-线程内存模型
Java Memory Model,JMM

	- JMM的设计目标：
定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。（主要是线程共享区域——堆的变量。）
	- 内存模型：主内存+工作内存
（所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。 每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、 赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。）

		- JMM和Java内存区域的区别：
主内存、 工作内存与Java内存区域中的Java堆、 栈、 方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、 主内存、 工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存。

			- JVM内存区域中线程隔离的区域：
虚拟机栈、程序计数器、本地方法栈
线程共享的区域：
堆、方法区

				- 共享变量在堆Heap中

		- 主内存和工作内存的交互：
一系列相互关联的原子性指令

			- 原子性指令

				- lock--unlock
				- read-load-use
				- assign-store-write

			- long、double变量的非原子性协定：
对于原子性的指令，可以把64位操作分为两次32位操作。但目前商用虚拟机还是通过具体实现保证了原子性。

	- Java虚拟机的即时编译器中有类似乱序执行优化的指令重排序（Instruction Reorder）优化

		- volatile修饰符的语义：
保证可见性，volatile变量不会被缓存在寄存器中（只有拥有线程可见）或者其他对CPU不可见的地方，每次总是从主存中读取volatile变量的结果。但不保证变量的原子性。比如自加操作不是原子操作，使用volatile变量是不能保证线程同步的。

此外，在语义上还禁用了指令重排序。

			- 应用volatile变量的三个原则：
    （1）写入变量不依赖此变量的值，或者只有一个线程修改此变量
    （2）变量的状态不需要与其它变量共同参与不变约束
    （3）访问变量不需要加锁

	- JMM的线程安全性问题

		- 线程安全性的内涵

			- 原子性Atomicity
单个线程执行一系列操作时是不可分割的
			- 可见性Visibility
可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 工作内存中的变量会即刻同步到主存。
			- 有序性Ordering
有序性（Ordering）：Java内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。 前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

		- Java存储模型中，JMM的先行发生原则
happen-before

			- 什么是先行发生原则

				- 先行发生是Java内存模型中定义的两项JMM操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、 发送了消息、 调用了方法等。 
JMM动作（Java Memeory Model Action），Java存储模型动作。
				- Java中天然的先行发生关系
无须同步器

					- 程序次序规则（Program Order Rule）：在一个线程内，程序操作按照控制流顺序发生。
					- 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。 这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
					- volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
					- 线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。
					- 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、 Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
					- 线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通Thread.interrupted（）方法检测到是否有中断发生。
					- 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。
					- 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

			- 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。

- Java虚拟机的线程执行模型

	- Java虚拟机的线程实现
（和平台有关）

		- JVM中的程序、进程和线程

			- 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
			- 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。
			- 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享【同一块内存空间和一组系统资源】，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

		- Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start（）且还未结束的java.lang.Thread类的实例就代表了一个线程。 
我们注意到Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。 在Java API中，一个Native方法往往意味着这个方法没有使用或无法使用
平台无关的手段来实现（当然也可能是为了执行效率而使用Native方法，不过，通常最高效率的手段也就是平台相关的手段）。 
		- 在目前的JDK版本中，线程模型为基于操作系统原生线程模型来实现。 因此，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。 线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是透明的。

			- Windows和Linux下，Java线程和操作系统线程是一对一的

	- 单个线程

		- 线程状态

			- 初始状态：NEW
线程被构建，但是还没有调用start()方法
			- 运行状态：RUNNABLE
包含Running（运行中）和Ready（就绪）两种状态，两种状态间靠系统调度进行切换，或用yield()方法主动从Running转为Ready。

				- Running和Ready的切换方法：
1）静态方法 Thread.yield() 

					- 可能抛出异常（为什么会抛出异常？线程中断、或者运行异常），跳至Terminated

			- 阻塞状态： BLOCKED
线程被动阻塞，等待获取一个锁，获取到锁后状态才会切换至运行状态。

				- 可能抛出异常，跳至
Terminated

			- 等待状态/无限期等待：WAITTING
该线程主动等待，其他线程做出一些特定动作后（通知或线程中断指令）显示唤醒该线程，该线程返回到运行状态。

				- 进入方法：
1）没有设置 Timeout 参数的 Object.wait() 方法，线程挂起
2）没有设置 Timeout 参数的 Thread.join() 方法
3）LockSupport.park() 方法
				- 退出方法：
1）其他线程调用Object.notify() / Object.notifyAll()
2）被调用的线程执行完毕
3）LockSupport.unpark(Thread)

					- 可能抛出异常，跳至
Terminated

			- 超时等待状态/限期等待：TIME_WAITTING
该线程主动等待，需其他线程做出一些特定动作（通知或线程中断指令）显示唤醒该线程，或者在指定时间后自行返回到运行状态。

				- 进入方法：
1）设置 Timeout 参数的 Thread.sleep() 静态方法，线程睡眠
2）设置 Timeout 参数的 Object.wait() 方法，线程挂起
3）设置 Timeout 参数的 Thread.join() 方法
4）LockSupport.parkNanos() 方法
5）LockSupport.parkUntil() 方法

					- 调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。（如果线程持有锁，锁不会被释放）

调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述，线程从竞争锁的锁池进入到一个和该对象相关的等待池。（持有的锁会被释放）

				- 退出方法：
1）设置的时间结束
2）其他线程调用Object.notify() / Object.notifyAll()
3）被调用的线程执行完毕
4）LockSupport.unpark(Thread)
5）LockSupport.unpark(Thread)

					- 可能抛出异常，跳至
Terminated

			- 终止状态：Terminated
该线程已经执行完毕，或者该线程因为产生异常提前结束。

				- 线程处于某个状态，出现异常时，由于异常不能跨线程传播，应该将异常在本地处理（比如手动实现向上传播）

				  public void run() {
				      try {
				          Thread.sleep(3000);
				      } catch (InterruptedException e) {
				          e.printStackTrace();
				      }
				  }

		- 线程属性

			- 线程优先级

				- 系统调度时，优先级高的线程更容易获得资源分配

					- 举例：
当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。

优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

			- 父线程和子线程

				- 子线程的生命可以不受父线程影响。

			- 守护线程和用户线程

				- 守护线程：
功能：守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
JVM在用户线程全部执行完后会退出，无视守护线程的运行情况。
可在线程启动之前，设定线程是否为守护线程

				  demoThread.setDaemon(true);//指定某个线程为守护线程

					- main() 属于非守护线程

		- 线程的创建和执行
执行器 Executor

			-     定义Thread类的子类，并重写该类的run方法（Thread类从Runnable接口继承），该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
    创建Thread子类的实例，即创建了线程对象。
    调用线程对象的start()方法来启动该线程。

			  public class MyThread extends Thread {
			      public void run() {
			          // ...
			      }
			  }
			  
			  public static void main(String[] args) {
			      MyThread mt = new MyThread();
			      mt.start();
			  }

				- 使用场景：
一般场景
				- 线程的 run()和 start()有什么区别？

每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。

start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。

run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接调用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

			-     定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
    创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
    调用线程对象的start()方法来启动该线程。

			  public class MyRunnable implements Runnable {
			      public void run() {
			          // ...
			      }
			  }
			  
			  public static void main(String[] args) {
			      MyRunnable instance = new MyRunnable();
			      Thread thread = new Thread(instance);
			      thread.start();
			  }

				- 使用场景：
希望线程执行较为复杂的任务

			-     创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
    创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
    使用FutureTask对象作为Thread对象的target创建并启动新线程。
    调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

			  public class MyCallable implements Callable<Integer> {
			      public Integer call() {
			          return 123;
			      }
			  }
			  
			  public static void main(String[] args) throws ExecutionException, InterruptedException {
			      MyCallable mc = new MyCallable();
			      FutureTask<Integer> ft = new FutureTask<>(mc);
			      Thread thread = new Thread(ft);
			      thread.start();
			      System.out.println(ft.get());
			  }

				- 使用场景：
希望线程执行较为复杂的任务，且有返回值
				- Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。
FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。

public class FutureTask<V> implements RunnableFuture<V>

public interface RunnableFuture<V> extends Runnable, Future<V>

					- 使用场景：
FutureTask 可用于异步获取执行结果或取消执行任务的场景。

			- 方法比较

				- 实现接口会更好一些，因为：
    Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
    类可能只要求可执行就行，继承整个 Thread 类开销过大。

	- 多个线程协作

		- 如何协调多个线程

			- 方法一：手动管理
			- 方法二：线程池 Executors
功能 ：管理多个异步任务的执行，无需程序员显式地管理线程的生命周期。（异步是指多个任务的执行互不干扰，不需要进行同步操作）

优点：
降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。
提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，
使用线程池可以进行统一的分配，调优和监控。

			  public static void main(String[] args) {
			      ExecutorService executorService = Executors.newCachedThreadPool();
			      for (int i = 0; i < 5; i++) {
			          executorService.execute(new MyRunnable());
			      }
			      executorService.shutdown();
			  }

				- 线程池的状态

					- shutdown()和shutdownNow()方法的区别
shutdown()方法，线程池状态立刻变成shutdown状态，线程池不再接受添加任务。当线程池中所有任务完成后，线程池退出。
shutdownNow()方法，线程池立刻变成stop状态，并试图停止所有正在执行的线程（对线程池中所有线程调用Thread.interrupt()方法），不再处理还在队列中的任务，返回未执行的任务。

				- 线程池的种类和创建

					- 通过ThreadPoolExecutor及其子类的构造方法创建（阿里巴巴开发手册指定方法）

						- 子类：ScheduledThreadPool
new ScheduledThreadPool(int corePoolSize)

创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

					- 通过Executor 框架的工具类Executors来创建线程池

						- new CachedThreadPool()

创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。
						- new FixedThreadPool(int nThreads)

创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。
						- new SingleThreadExecutor()

这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。

				- 线程池的执行：
将线程传入

					- submit()和 execute()方法有什么区别？
    接收的参数不一样，submit()接受Runnable类/Callable类为入参
    submit有返回值 Future类，内部调用execute，而execute没有返回值
    submit方便Exception处理

		- 资源的使用权如何在线程之间转移

			- Java虚拟机的线程调度

				- 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive ThreadsScheduling）。
				- Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。但物理机和虚拟机的优先级往往实现不一样，不能一一对应。且操作系统本身也存在可修改优先级的子程序，比如在Windows系统中存在一个称为“优先级推进器”（Priority Boosting，当然它可以被关闭掉）的功能。

			- 消息传递和控制传递

				- 线程中断

					- 某些情况下，需要一个线程改变目前的状态，如果采用直接终止的方式，是十分危险的。
线程中断不是直接终止线程，而是向线程传递一个中断信号, 线程可自行决定后续操作，可能是生吞中断，也可以采用向上传递中断。
					- 线程中断方法：thread的中断操作
void interrupt()  中断调用这个方法的线程
boolean interrupted()    返回调用这个方法的线程的中断状态，如果中断标志为true，清除中断标志，置为false
boolean isInterrupt()  返回调用这个方法的线程的中断状态

						- void interrupt()
通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。
例外：但是不能中断 I/O 阻塞和 synchronized 锁阻塞。

						  public class InterruptExample {
						      private static class MyThread1 extends Thread {
						          @Override
						          public void run() {
						              try {
						                  Thread.sleep(2000);//子线程如果被中断，则抛出异常，子线程退出
						                  System.out.println("Thread run");
						              } catch (InterruptedException e) {
						                  e.printStackTrace();
						              }
						          }
						      }
						  }
						  
						  public static void main(String[] args) throws InterruptedException {
						      Thread thread1 = new MyThread1();
						      thread1.start();
						      thread1.interrupt();
						      System.out.println("Main run");
						  }

						- boolean interrupted()
如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。

但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。

						  public class InterruptExample {
						  
						      private static class MyThread2 extends Thread {
						          @Override
						          public void run() {
						              while (!interrupted()) {//子线程检测自己是否被设置了中断标志
						                  // ..
						              }
						              System.out.println("Thread end");
						          }
						      }
						  }
						  
						  public static void main(String[] args) throws InterruptedException {
						      Thread thread2 = new MyThread2();
						      thread2.start();
						      thread2.interrupt();
						  }

						- boolean isInterrupt()
同上，但是不会重置中断标志

						  public boolean is Interrupted() {
						  ／／传递 false ，说明不清除中断标志
						  return isinterrupted (false) ;
						  }

					- 线程中断方法：Executor的中断操作
void shutdown()  调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭
void shutdownNow() 调用 shutdownNow() 方法，相当于调用每个线程的 interrupt() 方法
Future<?> submit() 用来提交Executor中的某个线程，再对线程执行中断操作

						- void shotdownNow()

						  public static void main(String[] args) {
						      ExecutorService executorService = Executors.newCachedThreadPool();
						      executorService.execute(() -> {
						          try {
						              Thread.sleep(2000);
						              System.out.println("Thread run");
						          } catch (InterruptedException e) {
						              e.printStackTrace();
						          }
						      });
						      executorService.shutdownNow();
						      System.out.println("Main run");
						  }

						- submit()
通过使用 submit() 方法来提交一个线程，它会返回一个 Future<?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。

						  Future<?> future = executorService.submit(() -> {
						      // ..
						  });
						  future.cancel(true);

				- Thread.sleep(millisec)

					- Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。但是不会释放锁

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

				- Thread.yield()

					- 线程调用静态方法 Thread.yield()，声明当前线程已经完成生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

					  public void run() {
					  
					      Thread.yield();
					  
					  }

				- Thread.join()

					- 在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。该方法可以用来保证线程之间执行结束的关系

					  对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。
					  
					  public class JoinExample {
					  
					      private class A extends Thread {
					          @Override
					          public void run() {
					              System.out.println("A");
					          }
					      }
					  
					      private class B extends Thread {
					  
					          private A a;
					  
					          B(A a) {
					              this.a = a;
					          }
					  
					          @Override
					          public void run() {
					              try {
					                  a.join();
					              } catch (InterruptedException e) {
					                  e.printStackTrace();
					              }
					              System.out.println("B");
					          }
					      }
					  
					      public void test() {
					          A a = new A();
					          B b = new B(a);
					          b.start();
					          a.start();
					      }
					  }
					  
					  public static void main(String[] args) {
					      JoinExample example = new JoinExample();
					      example.test();
					  }

				- Sychronized的对象锁+
Object.wait()
Object.notify()
Object.notifyAll()

					- 调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程调用 notify() 或者 notifyAll() 来唤醒挂起的线程。

它们都属于 Object 的一部分，而不属于 Thread。

只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。

使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

					  public class WaitNotifyExample {
					  
					      public synchronized void before() {
					          System.out.println("before");
					          notifyAll();
					      }
					  
					      public synchronized void after() {
					          try {
					              wait();
					          } catch (InterruptedException e) {
					              e.printStackTrace();
					          }
					          System.out.println("after");
					      }
					  }
					  
					  public static void main(String[] args) {
					      ExecutorService executorService = Executors.newCachedThreadPool();
					      WaitNotifyExample example = new WaitNotifyExample();
					      executorService.execute(() -> example.after());
					      executorService.execute(() -> example.before());
					  }
					  
					  before
					  after

				- ReentrantLock+
Condition.await()
Condition.signal()
Condition.signalAll()

					- java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。

相比于 wait() 这种等待方式，await() 可以为多个线程指定等待的条件，因此更加灵活。

使用 Lock 来获取一个 Condition 对象。

					  class BoundedBuffer {
					     final Lock lock = new ReentrantLock();//锁对象
					     final Condition notFull  = lock.newCondition();//写线程条件 
					     final Condition notEmpty = lock.newCondition();//读线程条件 
					   
					     final Object[] items = new Object[100];//缓存队列
					     int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/;
					   
					     public void put(Object x) throws InterruptedException {
					       lock.lock();
					       try {
					         while (count == items.length)//如果队列满了 
					           notFull.await();//阻塞写线程
					         items[putptr] = x;//赋值 
					         if (++putptr == items.length) putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0
					         ++count;//个数++
					         notEmpty.signal();//唤醒读线程
					       } finally {
					         lock.unlock();
					       }
					     }
					   
					     public Object take() throws InterruptedException {
					       lock.lock();
					       try {
					         while (count == 0)//如果队列为空
					           notEmpty.await();//阻塞读线程
					         Object x = items[takeptr];//取值 
					         if (++takeptr == items.length) takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0
					         --count;//个数--
					         notFull.signal();//唤醒写线程
					         return x;
					       } finally {
					         lock.unlock();
					       }
					     } 
					   }

		- 线程上下文切换

			- 线程上下文切换的时机：
第一种：当前线程的CPU时间片使用完，处于就绪状态
第二种：当前线程被其他线程中断。

- 并发程序设计（Java）

	- 并发问题

		- 死锁问题

			- 产生条件

				-     互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
    请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
    不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
    环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系

			- 解决思路

				- 在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。

此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

	- 并发问题的解决
（线程安全性和并发性的矛盾）

		- 线程安全性

			- 线程安全的程度：
线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、 绝对线程安全、 相对线程安全、 线程兼容和线程对立。

				- 理解：什么算是并发的正确性？
线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。 这点听起来简单，但其实并不容易做到，在大多数场景中，我们都会将这个定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”，这个定义的其他描述也能够成立的话，我们就可以称它是线程安全了。
				- 线程对立：
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。 由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。

			- 实现线程安全性的主要方面

				- 原子性Atomicity

					- 提供互斥访问，同一时刻只能有一个线程对数据进行操作（atomic,synchronized）；

				- 可见性Visibility

					- 一个线程对主内存的修改可以及时地被其他线程看到（synchronized,volatile）；

						- synchronized 和 volatile 的区别是什么？

    volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

    volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。

    volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。

    volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

    volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

				- 有序性Ordering

					- 一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序（happens-before原则）。

			- 实现工具：
实现并发的基础构建模块
（主要讲应用，具体原理和源代码见JDK类库部分）

				- 同步容器类：
线程安全的容器

					- Vector
					- HashTable

				- 并发容器类：
克服同步容器类串行访问的缺点

					- ConcurrentHashMap
用于替代同步且基于散列的Map
					- CopyOnWriteArrayList
用于替代遍历为主要操作的同步List
					- ConcurrentSkipListMap
替代同步的SortedMap
					- ConcurrentSkipListSet
替代同步的SortedSet
					- Queue
队列

						- LinkedQueue
FIFO 队列

							- 使用场景：
生产者消费者问题

							  public class ProducerConsumer {
							  
							      private static BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
							  
							      private static class Producer extends Thread {
							          @Override
							          public void run() {
							              try {
							                  queue.put("product");
							              } catch (InterruptedException e) {
							                  e.printStackTrace();
							              }
							              System.out.print("produce..");
							          }
							      }
							  
							      private static class Consumer extends Thread {
							  
							          @Override
							          public void run() {
							              try {
							                  String product = queue.take();
							              } catch (InterruptedException e) {
							                  e.printStackTrace();
							              }
							              System.out.print("consume..");
							          }
							      }
							  }
							  
							  public static void main(String[] args) {
							      for (int i = 0; i < 2; i++) {
							          Producer producer = new Producer();
							          producer.start();
							      }
							      for (int i = 0; i < 5; i++) {
							          Consumer consumer = new Consumer();
							          consumer.start();
							      }
							      for (int i = 0; i < 3; i++) {
							          Producer producer = new Producer();
							          producer.start();
							      }
							  }

							- 接口方法：
void put(String s)
void take()

						- PriorityQueue
（非并发的）优先级队列

							- 使用场景：
生产者消费者问题

					- BlockingQueue
阻塞队列，既是容器，也是协调工具

						- LinkedBlockingQueue
FIFO 队列

							- 使用场景：
生产者消费者问题

							  public class ProducerConsumer {
							  
							      private static BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);
							  
							      private static class Producer extends Thread {
							          @Override
							          public void run() {
							              try {
							                  queue.put("product");
							              } catch (InterruptedException e) {
							                  e.printStackTrace();
							              }
							              System.out.print("produce..");
							          }
							      }
							  
							      private static class Consumer extends Thread {
							  
							          @Override
							          public void run() {
							              try {
							                  String product = queue.take();
							              } catch (InterruptedException e) {
							                  e.printStackTrace();
							              }
							              System.out.print("consume..");
							          }
							      }
							  }
							  
							  public static void main(String[] args) {
							      for (int i = 0; i < 2; i++) {
							          Producer producer = new Producer();
							          producer.start();
							      }
							      for (int i = 0; i < 5; i++) {
							          Consumer consumer = new Consumer();
							          consumer.start();
							      }
							      for (int i = 0; i < 3; i++) {
							          Producer producer = new Producer();
							          producer.start();
							      }
							  }

							- 接口方法：
void put(String s)
void take()

						- ArrayBlockingQueue
固定长度的FIFO队列

							- 使用场景：
生产者消费者问题

						- 优先级队列

							- PriorityBlockingQueue

				- 同步工具类Synchronizer：
用于协调多个线程控制流的类

					- 基于AQS实现的一系列同步工具类
					- BlockingQueue
阻塞队列
					- Semaphore
信号量

						- Semaphore
信号量

							- 使用场景：
可以控制对互斥资源的访问线程数。
							- 接口方法：
acquire()
release()

							  以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。
							  
							  public class SemaphoreExample {
							  
							      public static void main(String[] args) {
							          final int clientCount = 3;
							          final int totalRequestCount = 10;
							          Semaphore semaphore = new Semaphore(clientCount);
							          ExecutorService executorService = Executors.newCachedThreadPool();
							          for (int i = 0; i < totalRequestCount; i++) {
							              executorService.execute(()->{
							                  try {
							                      semaphore.acquire();
							                      System.out.print(semaphore.availablePermits() + " ");
							                  } catch (InterruptedException e) {
							                      e.printStackTrace();
							                  } finally {
							                      semaphore.release();
							                  }
							              });
							          }
							          executorService.shutdown();
							      }
							  }

					- Barrier
栅栏

						- CyclicBarrier
循环屏障

							- 使用场景：
用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。

CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。
							- 构造器：
CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。

							  public CyclicBarrier(int parties, Runnable barrierAction) {
							      if (parties <= 0) throw new IllegalArgumentException();
							      this.parties = parties;
							      this.count = parties;
							      this.barrierCommand = barrierAction;
							  }
							  
							  public CyclicBarrier(int parties) {
							      this(parties, null);
							  }

							- 接口方法：
await()
reset()

							  public class CyclicBarrierExample {
							  
							      public static void main(String[] args) {
							          final int totalThread = 10;
							          CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
							          ExecutorService executorService = Executors.newCachedThreadPool();
							          for (int i = 0; i < totalThread; i++) {
							              executorService.execute(() -> {
							                  System.out.print("before..");
							                  try {
							                      cyclicBarrier.await();
							                  } catch (InterruptedException | BrokenBarrierException e) {
							                      e.printStackTrace();
							                  }
							                  System.out.print("after..");
							              });
							          }
							          executorService.shutdown();
							      }
							  }

					- Latch
闭锁

						- CountLatchDown
倒计时器

							- 使用场景：
在一些应用场合中，需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，以便进行后面的操作。 这个时候就可以使用CountDownLatch。
							- 接口方法：
public void countDown()
    递减锁存器的计数，如果计数到达零，则释放所有等待的线程。如果当前计数大于零，则将计数减少。如果新的计数为零，出于线程调度目的，将重新启用所有的等待线程。
    如果当前计数等于零，则不发生任何操作。


public boolean await(long timeout, TimeUnit unit) throws InterruptedException
参数：
        timeout - 要等待的最长时间
        unit - timeout 参数的时间单位
返回：
        如果计数到达零，则返回 true；如果在计数到达零之前超过了等待时间，则返回 false 
抛出：
        InterruptedException - 如果当前线程在等待时被中断

    使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。如果当前计数为零，则此方法立刻返回 true 值。
    如果当前计数大于零，则出于线程调度目的，将禁用当前线程，且在发生以下三种情况之一前，该线程将一直处于休眠状态：
        1）由于调用 countDown() 方法，计数到达零；或者
        2）其他某个线程中断当前线程；或者
        3）已超出指定的等待时间。

							  public class CountDownLatchTest {
							  
							      // 模拟了100米赛跑，10名选手已经准备就绪，只等裁判一声令下。当所有人都到达终点时，比赛结束。
							      public static void main(String[] args) throws InterruptedException {
							  
							          // 开始的倒数锁 
							          final CountDownLatch begin = new CountDownLatch(1);  
							  
							          // 结束的倒数锁 
							          final CountDownLatch end = new CountDownLatch(10);  
							  
							          // 十名选手 
							          final ExecutorService exec = Executors.newFixedThreadPool(10);  
							  
							          for (int index = 0; index < 10; index++) {
							              final int NO = index + 1;  
							              Runnable run = new Runnable() {
							                  public void run() {  
							                      try {  
							                          // 如果当前计数为零，则此方法立即返回。
							                          // 等待
							                          begin.await();  
							                          Thread.sleep((long) (Math.random() * 10000));  
							                          System.out.println("No." + NO + " arrived");  
							                      } catch (InterruptedException e) {  
							                      } finally {  
							                          // 每个选手到达终点时，end就减一
							                          end.countDown();
							                      }  
							                  }  
							              };  
							              exec.submit(run);
							          }  
							          System.out.println("Game Start");  
							          // begin减一，开始游戏
							          begin.countDown();  
							          // 等待end变为0，即所有选手到达终点
							          end.await();  
							          System.out.println("Game Over");  
							          exec.shutdown();  
							      }
							  }

			- 实现方式

				- 互斥同步（Mutual Exclusion＆Synchronization）==阻塞同步
--同步的意思是协同步调，当一个线程进入临界区后，其他线程必须等待
--属于悲观的并发策略

					- 互斥是实现同步的一种手段，临界区（Critical
Section）、 互斥量（Mutex）和信号量（Semaphore）、事件（Event）都是主要的互斥实现方式。
					- 实现方法

						- 内置锁=同步锁=监视器锁
（synchronized关键字）
由JVM实现

							- 实现原理：
synchronized修饰的代码块在编译为字节码后，前后生成了monitorenter和monitorexit指令。
虚拟机的线程执行至monitorenter指令时，尝试获取对象的锁（通过monitorenter指令的reference参数找到对象，通过对象头的信息判断锁是否可获得）：
如果这个对象没有锁定，或者当前线程已经拥有了该对象的锁，把锁的计数器+1； 当执行monitorexit指令时将锁计数器-1；当计数器为0时，锁就被释放了。如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

								- 底层依赖：
操作系统层面的互斥锁，对象头中markword
								- 内存语义：
和其他的加锁释放锁的语义一样。
进入synchronized块的语义是把使用到的变量从线程的工作内存中清除，直接从主内存中获取需要的变量。
退出synchronized块的语义是将代码块内对变量的修改刷新到主存。

							- 锁定的对象：
1. 类锁：在代码中的静态static方法上加了synchronized的锁，或者synchronized(xxx.class）的代码段，对该对象的类对象（Class对象）加锁。
2.对象锁：在代码中的非静态方法（也就是实例方法）上加了synchronized的锁，或者synchronized(this）的代码段，对该对象加锁。此时，对象内未被synchronized标注的实例方法仍然是非互斥的，可用的。
3.私有锁：在类内部声明一个私有属性如private Object ob，在需要加锁的代码段synchronized(ob）

								- 类锁

									- 同步一个类，即同步一个类下的所有对象
public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}

									  作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。
									  
									  public class SynchronizedExample {
									  
									      public void func2() {
									          synchronized (SynchronizedExample.class) {
									              for (int i = 0; i < 10; i++) {
									                  System.out.print(i + " ");
									              }
									          }
									      }
									  }
									  
									  public static void main(String[] args) {
									      SynchronizedExample e1 = new SynchronizedExample();
									      SynchronizedExample e2 = new SynchronizedExample();
									      ExecutorService executorService = Executors.newCachedThreadPool();
									      executorService.execute(() -> e1.func2());
									      executorService.execute(() -> e2.func2());
									  }
									  
									  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9

									- 同步一个静态方法
public synchronized static void fun() {
    // ...
}

								- 对象锁

									- 同步一个代码块
public void func() {
    synchronized (this) {
        // ...
    }
}

										- 示例：两线程对同一代码块同步访问

										  对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。
										  
										  public class SynchronizedExample {
										      public void func1() {
										          synchronized (this) {
										              for (int i = 0; i < 10; i++) {
										                  System.out.print(i + " ");
										              }
										          }
										      }
										  }
										  
										  public static void main(String[] args) {
										      SynchronizedExample e1 = new SynchronizedExample();
										      ExecutorService executorService = Executors.newCachedThreadPool();
										      executorService.execute(() -> e1.func1());
										      executorService.execute(() -> e1.func1());
										  }

										- 示例：两线程异步访问

										  对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。
										  
										  public static void main(String[] args) {
										      SynchronizedExample e1 = new SynchronizedExample();
										      SynchronizedExample e2 = new SynchronizedExample();
										      ExecutorService executorService = Executors.newCachedThreadPool();
										      executorService.execute(() -> e1.func1());
										      executorService.execute(() -> e2.func1());
										  }
										  
										  0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9

									- 同步一个实例方法
public synchronized void func () {
    // ...
}

								- 私有锁

							- 锁的使用性质：
1）可重入：同一个线程，获取某个锁后，可以再次获取这个锁。避免阻塞。
2）非公平锁：在多个等待的线程中，并不是先到先得

						- JVM对synchronized关键字的锁优化：
克服了synchronized阻塞挂起性能消耗较大的问题。总体上使得synchronized性能和ReentrantLock性能接近

							- 自旋锁

								- 优化点：
互斥同步进入阻塞状态的开销都很大，应该尽量减少阻塞挂起的使用。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。
								- 使用场景：
自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。

在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。

							- 锁消除

								- 优化点：
锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。

锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。

								  对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：
								  
								  public static String concatString(String s1, String s2, String s3) {
								      return s1 + s2 + s3;
								  }
								  
								  String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：
								  
								  public static String concatString(String s1, String s2, String s3) {
								      StringBuffer sb = new StringBuffer();
								      sb.append(s1);
								      sb.append(s2);
								      sb.append(s3);
								      return sb.toString();
								  }
								  
								  每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。

							- 锁粗化

								- 优化点：
如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。

							- synchronize的monitor实现：
JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。

以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态。


								- 一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。
								- 重量级锁

									- 概念：

								- 轻量级锁
和锁膨胀

									- 概念：
									- 优化原理：
轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。
对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。
									- 实现原理：
当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。
如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。

								- 偏向锁

									- 概念：
									- 优化原理：
偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。
									- 实现原理：
当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

						- ReentrantLock锁和Condition条件
由JDK中J.U.C实现

							- 实现原理

								- ReentrantLock底层调用的是Unsafe的park方法加锁

							- 锁定的对象：
调用lock()方法的对象

								- 同步一个代码块

								  public class LockExample {
								  
								      private Lock lock = new ReentrantLock();
								  
								      public void func() {
								          lock.lock();
								          try {
								              for (int i = 0; i < 10; i++) {
								                  System.out.print(i + " ");
								              }
								          } finally {
								              lock.unlock(); // 确保释放锁，从而避免发生死锁。
								          }
								      }
								  }
								  
								  public static void main(String[] args) {
								      LockExample lockExample = new LockExample();
								      ExecutorService executorService = Executors.newCachedThreadPool();
								      executorService.execute(() -> lockExample.func());
								      executorService.execute(() -> lockExample.func());
								  }
								  
								  结果：0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9

							- 锁的使用性质：
1）可重入
2）默认非公平锁，可设置为公平锁
3）可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

						- 方法比较

							- 在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁（lock（）和unlock（）方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。 不过，相比synchronized,ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、 可实现公平锁，以及锁可以绑定多个条件（Condition）。

								-     ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 
								-     ReentrantLock可以获取各种锁的信息
								-     ReentrantLock可以灵活地实现多路通知 

							- 两者性能基本接近，除非需要使用 ReentrantLock 的高级功能（Condition），否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

				- 非阻塞同步方法
--允许多个线程同时进入临界区
--基于冲突检测的乐观的并发策略

					- 实现基础：
基于原子性的硬件指令集，才能有效实现

主要是unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。

						- 测试并设置（Test-and-Set）
						- 获取并增加（Fetch-and-Increment）
						- 交换（Swap）
						- 比较并交换（Compare-and-Swap，简称CAS）
						- 加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）

					- 实现方式

						- 原子变量
（基于CAS实现）

							- CAS带来的ABA问题

								- J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

				- 无同步方法

					- 如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。
					- 实现方式

						- 线程封闭

							- 栈封闭
							- 线程本地存储

								- 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

							- 可重入代码

			- ForkJoin和ForkJoinPool

				- 主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。
				- 举例

				  public class ForkJoinExample extends RecursiveTask<Integer> {
				  
				      private final int threshold = 5;
				      private int first;
				      private int last;
				  
				      public ForkJoinExample(int first, int last) {
				          this.first = first;
				          this.last = last;
				      }
				  
				      @Override
				      protected Integer compute() {
				          int result = 0;
				          if (last - first <= threshold) {
				              // 任务足够小则直接计算
				              for (int i = first; i <= last; i++) {
				                  result += i;
				              }
				          } else {
				              // 拆分成小任务
				              int middle = first + (last - first) / 2;
				              ForkJoinExample leftTask = new ForkJoinExample(first, middle);
				              ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
				              leftTask.fork();
				              rightTask.fork();
				              result = leftTask.join() + rightTask.join();
				          }
				          return result;
				      }
				  }
				  
				  public static void main(String[] args) throws ExecutionException, InterruptedException {
				      ForkJoinExample example = new ForkJoinExample(1, 10000);
				      ForkJoinPool forkJoinPool = new ForkJoinPool();
				      Future result = forkJoinPool.submit(example);
				      System.out.println(result.get());
				  }

				- ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。

		- 并行性

*XMind: ZEN - Trial Version*