# 编程语言
Programme Language 
——————————
Java体系

学习编程语言：写出符合合法的语句（合法：语法正确）



学习程序设计：设计出可靠、鲁棒、健壮的程序

？





学习软件工程：多程序协作

？

## Java Development Kit (JDK)

它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。

### 语言
Java Language

### 开发工具和工具接口
Tools & Tool APIs

- 编译器
javac.exe
- 调试器
jdb.exe
- 剖析工具
javaprof.exe
- 文件反编译工具
javap.exe
- 文档生成工具
javadoc.exe
- Jar包生成工具
jar.exe
- 控制台工具
JConsole.exe
- 远程方法调用（工具接口）
RMI(Remote Method Invocation)
- 数据库（工具接口）
Java DB
- 其他开发工具和工具接口

### Java Runtime Environment (JRE)

java 运行时环境JRE
它是运行已编译 Java 程序所需的所有内容的集合，，是 JVM 的实施实现，提供了运行 java 程序的平台。包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，但是不包含 java 编译器 / 调试器之类的开发工具，它不能用于创建新程序。

- Java Virtual Machine (JVM)

  java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。
  注意区分JVM规范和虚拟机的具体实现，比如JVM对内存区域划分了方法区，而HotSpot虚拟机将方法区具体实现为永久区。
  
  参考资料：
  《深入理解JVM虚拟机》

- 基础支持构件

	- 部署构件
Deployment

		- Java Web Starter
		- Applet/Java Plug-in

	- 用户界面工具包
User Interface Toolkits

		- JavaFX
		- Swing
		- AWT
		- 其他部分

- Libraries
Java类库

	- 常用系统基础包
java.base package

		- [P] java.lang.* 
（提供语言特性）

			- [P] java.lang
(提供基本的编程支持）

			  提供java语言程序设计的基础类(基础数据类型的封装类、Class、math、线程类)。lang包中的类的应用不需要手动import。

				- 类型部分

					- 对象基类

						- [C] java.lang.Object

						  Object实现的方法:clone(只有实现Cloneable接口才可调用)；getClass，toString，hashCode，equals，finalize(释放资源)，wait，notifyAll，notify。

					- 类型信息

						- [C] java.lang.Class
						- [C] java.lang.ClassLoader
						- [C] java.lang.Complier

					- 无数据

						- [C] java.lang.void

					- 基础数据类型的封装

						- [C] java.lang.Boolean
						- [C] java.lang.Character
						- [C] java.lang.String
							- [C] java.lang.Byte
							- [C] java.lang.Short
							- [C] java.lang.Integer
							- [C] java.lang.Long
							- [C] java.lang.Float
							- [C] java.lang.Double

					- 字符序列

						- [C] java.lang.StringBuilder
						- [C] java.lang.StringBuffer

					- [C] java.lang.Enum
枚举
					- [C] java.lang.Package
包
					- [C] java.lang.Iterable
迭代器
					- [C] java.lang.Comparable
比较器

				- 工具部分

					- 数学

						- [C] java.lang.math

					- 安全

						- [C] java.lang.SecurityManager

					- 注解

						- [C] java.lang.Override

				- 系统部分

					- 进程

						- [C] java.lang.Process

					- 线程

						- [C] java.lang.Thread

					- 运行

						- [C] java.lang.System
输入输出流、错误流的父类

						  1)三个对象:InputStream in;//标准输入流PrintStream out;//标准输出流PrintStream err;//标准错误流。如System.out.println();
						  2)常用方法:arraycopy(被复制数组,起始位置，复制到的数组，起始位置，复制长度);数组复制;
						  currentTimeMillis()和Date类中getTime方法完全是一样的;
						  gc()垃圾，回收不许要手动调用;

						- [C] java.lang.Runnable
						- [C] java.lang.RunTime

					- 堆栈

						- [C] java.lang.StackTraceElement

					- 异常

						- [C] java.lang.Throwable

							- [C] java.lang.Error
							- [C] java.lang.Exception

			- [P] java.lang.annotation
（强化注解）
			- [P] java.lang.reflect
（支持反射机制）
			- 其他部分等等

		- [P] java.util.*
（提供程序设计的工具设施）

			- [P] java.util
（提供基础的工具设施）

			  包含集合框架、遗留的 collection 类、事件模型、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组、日期Date类、堆栈Stack类、向量Vector类等）

				- 集合框架部分 collection framwork
（集合框架是为表示和操作集合而规定的一种统一的标准的体系结构，能够通过统一的接口设计的不同类。任何集合框架都包含三大内容：对外的接口、接口的实现和对集合运算的算法。）

					- 接口的继承关系

						- [I] java.util.RandomAccess 
标识支持随机访问

						  源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。

						- [I] java.util.iterator<E> 
支持从前往后顺序访问和增加元素
继承关系：继承自[I] java.lang.Iterable
迭代器

						  包含方法：
						  E next();
						  boolean hasNextO;
						  void remove0;
						  default void forEachRemaining(Consumer<? super E> action);

							- [I] java.util.Listlterator
支持任意方向顺序访问和增加元素

						- [I] java.util.comparator<E> 
支持元素比较

						  包含方法：
						  E next();
						  boolean hasNextO;
						  void remove0;
						  default void forEachRemaining(Consumer<? super E> action);

						- [I] java.util.collection <E> 
提供基本的增查删清、迭代器、提供size信息、提供hashcode信息、转为数组对象的方法，

							- [I] java.util.List<E>
有序集合ordered collection，支持通过索引随机访问random access

							  void add(int index, E element)
							  void remove(int index)
							  E get(int index)
							  E set(int index, E element)

							- [I] java.util.Set<E>
无序集合unordered collection，不允许有重复的元素
能够快速查找

								- [I] java.util.SortedSet
增加了比较器，用于排序（？）

									- [I] java.util.NavigableSet
增加了搜索功能

							- [I] java.util.Queue<E> 

						- [I] java.uti.map<E> 
增加键值映射等方法

							- [I] java.util.SortedMap
增加了比较器，用于排序

								- [I] java.util.NavigableMap
增加了搜索功能

					- 集合类的继承关系

						- [C] java.util.AbstractCollection

							- [C]  java.util.AbstractList
设计功能：List<E>接口的基础实现
继承关系：public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>

								- [C]  java.util.ArrayList
设计功能：一种可以动态增长和缩减的索引序列，非线程同步，支持高效的随机访问
内部存储：数组，有序集合
其他实现的接口：
比较器需实现comparable接口
实现了RandomAccess接口

								  因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。
								  
								  public class ArrayList<E> extends AbstractList<E>
								          implements List<E>, RandomAccess, Cloneable, java.io.Serializable

								- [C]  java.util.AbstracSequentialList
设计功能：增加顺序访问的支持

									- [C]  java.util.LinkedList
设计功能：一种可以在任何位置进行高效地插人和删除操作的有序序列，非线程同步，不支持高效的随机访问。可用作栈、队列和双向队列。
继承关系：List<E> + Queue<E>
内部存储：双向链表，有序集合
性能：可高效插入、删除元素
其他实现的接口：
比较器需实现comparable接口
没有实现RandomAccess接口

								- [C]  java.util.Vector
设计功能：和ArraysList接近，但所有方法都是线程同步的。ArraysList不是线程同步的。
内部存储：数组，有序集合


									- [C]  java.util.Stack

								- 备注：
list大类下 的遍历方式选择：

    实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach,
    未实现 RandomAccess接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环

							- [C]  java.util.AbstractSet

								- [C]  java.util.HashSet
设计功能：一种没有重复元素的无序集合
内部存储：哈希表（数组链表/链表散列），无序集合，非同步。基本上是对HashMap的包装
性能：查找性能O(1)
其他实现接口：判等器 hashcode()方法

									- [C]  java.util.LinkedHashSet
设计功能：一种可以记住元素插人次序的集
内部存储：哈希表（双向链表），无序集合
性能：查找性能O(1)
其他实现接口：判等器 hashcode()方法

								- [C]  java.util.TreeSet
设计功能：一种有序集，支持有序性操作，比如可根据一个范围快速查找元素的操作。 
内部存储：红黑树，有序集合
性能：查找性能O(logN)
其他实现接口：
比较器 compareTo()方法
								- [C]  java.util.EnumSet
设计功能：一种包含枚举类型值的集

							- [C]  java.util.AbstractQueue

								- [C] java.util.PriorityQueue<E>
设计功能：优先级队列
内部存储：堆
性能：

								  在 Queue 中 poll()和 remove()有什么区别？
								  
								  
								  poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

						- [C]  java.util.AbstractMap

							- [C]  java.util.HashMap
设计功能：一种存储键 / 值关联的映射表，线程不安全，允许Null键值
内部存储：哈希表（链表散列），无序集合；当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)
重要实现接口：判等器 hashcode()、equals()、containsKey()、containsValue()

							  当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头（头插法）,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。
							  
							  需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)

								- [C]   java.util.LinkedHashMap
设计功能：一种可以记住键 / 值项添加次序的映射表
内部存储：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

							- [I] java.util.SortedMap

								- [C]  java.util.TreeMap
设计功能：—种键值有序排列的映射表，适合遍历元素的操作
内部存储：红黑树

							- [C]  java.util.EnumMap
设计功能：一种键值属于枚举类型的映射表
							- [C]  java.util.WeakHashMap
设计功能：一种其值无用武之地后可以被垃圾回收器回收的映射表
							- [C] java.util.HashTable
和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。
它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，且因为 ConcurrentHashMap 引入了分段锁，效率会更高。
							- [C]  java.util.IdentityHashMap
设计功能：一种用 = 而不是用 equals 比较键值的映射表

								- ==与equals的区别

    ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
    ==是指对内存地址进行比较 equals()是对字符串的内容进行比较
    ==指引用是否相同 equals()指的是值是否相同

						- [C]  java.util.AbstractQueue

							- [C]  java.util.PriorityQueue
设计功能：一种允许高效删除最小元素的集合

						- [C] java.util.ArrayQueue
设计功能：一种用循环数组实现的双端队列

				- 字符串处理部分
string parsing and scanning

					- [C]  java.util.stringJoiner
					- [C]  java.util.string.Tokenizer

				- 事件模型部分
event model

					- [C]  java.util.eventObject
					- [C]  java.util.eventListener

				- 日期和时间
Date & Time

					- [C]  java.util.Calendar

						- GregorianCalendar它实现了世界上普遍使用的公历系统
						- import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

					- [C] java.util.date
					- [C]  java.util.Timer
定时器

						- [C] java.util.TimerTask

				- 国际化支持
internationalization support

					- [C] java.util.TimeZone

				- 编译信息
64位解码和编码
base64 encoding and decoding

					- [C] java.util.System

				- 其他工具类

					- 随机数生成器
random number generation

						- [C]  java.util.Random

					- 位数组
bit array

						- [C]  java.util.bitset

					- several miscellaneous utility classes

				- 其他部分等等

					- 遗留的集合类和遗留的时间类

			- [P] java.util.concurrent.*
（提供并发编程的工具设施）

				- [P] java.util.concurrent.Atomic
（提供原子变量类）

					- 引用的重要类或机制：
CAS
					- 说明：原子变量是多变的，不宜用来作为哈希表的键
原子变量并非是要取代java.lang包中的数据包装类
原子操作常和volatile修饰符一起用，保证线程安全性。
volatile可以看作是轻量级锁。
					- java.util.concurrent.atomic.AtomicInteger/AtomicLong/AtomicBoolean/AtomicReference差不多

					  int addAndGet(int delta)
					            以原子方式将给定值与当前值相加。 实际上就是等于线程安全版本的i =i+delta操作。
					  
					  boolean compareAndSet(int expect, int update)
					            如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 如果成功就返回true，否则返回false，并且不修改原值。
					  
					  int decrementAndGet()
					            以原子方式将当前值减 1。 相当于线程安全版本的--i操作。
					  
					  int get()
					            获取当前值。
					  
					  int getAndAdd(int delta)
					            以原子方式将给定值与当前值相加。 相当于线程安全版本的t=i;i+=delta;return t;操作。
					  
					  int getAndDecrement()
					            以原子方式将当前值减 1。 相当于线程安全版本的i--操作。
					  
					  int getAndIncrement()
					            以原子方式将当前值加 1。 相当于线程安全版本的i++操作。
					  
					  int getAndSet(int newValue)
					            以原子方式设置为给定值，并返回旧值。 相当于线程安全版本的t=i;i=newValue;return t;操作。
					  
					  int incrementAndGet()
					            以原子方式将当前值加 1。 相当于线程安全版本的++i操作。 
					  
					  void lazySet(int newValue)
					            最后设置为给定值。 延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。
					  
					  void set(int newValue)
					            设置为给定值。 直接修改原始值，也就是i=newValue操作。
					  
					  boolean weakCompareAndSet(int expect, int update)
					            如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但不 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。

					- java.util.concurrent.atomic.AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray差不多

					  void set(int i, int newValue)
					  void lazySet(int i, int newValue)
					  int getAndSet(int i, int newValue)
					  boolean compareAndSet(int i, int expect, int update)
					  boolean weakCompareAndSet(int i, int expect, int update)
					  int getAndIncrement(int i)
					  int getAndDecrement(int i)
					  int getAndAdd(int i, int delta)
					  int incrementAndGet(int i)
					  int decrementAndGet(int i)
					  int addAndGet(int i, int delta)

					- java.util.concurrent.atomic.AtomicIntegerFieldUpdater<T>/AtomicLongFieldUpdater<T>/AtomicReferenceFieldUpdater<T,V>是基于反射的原子更新对象字段的值。
					- AtomicMarkableReference类描述的一个<Object,Boolean>的对，可以原子的修改Object或者Boolean的值，这种数据结构在一些缓存或者状态描述中比较有用。这种结构在单个或者同时修改Object/Boolean的时候能够有效的提高吞吐量。
					- AtomicStampedReference类维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。对比AtomicMarkableReference类的<Object,Boolean>，AtomicStampedReference维护的是一种类似<Object,int>的数据结构，其实就是对对象（引用）的一个并发计数。但是与AtomicInteger不同的是，此数据结构可以携带一个对象引用（Object），并且能够对此对象和计数同时进行原子操作。

				- [P] java.util.concurent.locks
（提供锁机制）

					- 说明：
锁机制存在以下问题：
（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。
（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。
（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。
					- 接口的继承关系

						- [I] java.util.concurent.locks.Lock
						-  java.util.concurent.locks.Condition
						-  java.util.concurent.locks.ReadWriteLock

					- 类的继承关系

						- 同步器/同步工具类
Synchronizer

							- [C] java.util.concurrent.locks.AbstractQueuedSynchronizer，简称AQS

						- 锁
locks

							- [C]  java.util.concurrent.locks.ReentrantLock

								- 和Sychronized相比的特点：
同样是可重入锁，但增加了可中断、可限时、可选择公平锁或非公平锁，可绑定多个Condition的特点

							- [C]   java.util.concurrent.locks.ReentrantReadWriteLock

							  private static ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock(); 
							  private static Lock readLock = readWriteLock.readLock(); 
							  private static Lock writeLock = readWriteLock.writeLock();

								- ReadWriteLock是区分功能的锁。读和写是两种不同的功能，读-读不互斥，读-写互斥，写-写互斥。

							- [C] java.util.concurrent.locks.stampedLock

								- 该类是一个ReadWriteLock锁的改进，它的思想是读写锁中读不仅不阻塞读，同时也不应该阻塞写。

							- 联系至synchronized关键字

								- 不要synchronized一个不变对象，因为此类对象每次都是新的，例如 Integer String 等

				- [P] java.util.concurrent

					- 并发集合类
Concurrent Collection

						- 队列
Queue

							- BlockingQueue

						- 映射
Map
						- 列表
List

							- [C] java.util.concurrentCopyOnWriteArrayList<E>

								- 写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。

写操作需要加锁，防止并发写入时导致写入数据丢失。

写操作结束之后需要把原始数组指向新的复制数组。
								- 适用场景

CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。

但是 CopyOnWriteArrayList 有其缺陷：

    内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；
    数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。

所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。

					- 执行器
Executor

						- 线程池

							- 提交方式
							- 回调接口
							- 拒绝策略

					- 工具类
Tools

						- [C]  java.util.concurrent.CountDownLatch
闭锁/倒计时计数器
						- [C] java.util.concurrent.CyclicBarrier
筹齐计数器
						- [C] java.util.concurrent.Semaphore
信号量

						  acquire()申请许可，可申请多份
						  release()释放许可

							- 它允许多个线程同时进入临界区。可以认为它是一个共享锁，但是共享的额度是有限制的，额度用完了，其他没有拿到额度的线程还是要阻塞在临界区外。当额度为1时，就相等于lock

			- [P] java.util.regex
（支持正则表达式）

		- [P] java.io.*
（提供虚拟机层面I/O操作的支持）

			- 磁盘操作

				- [C] File
用于表示文件和目录的信息，但是它不表示文件的内容。File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。

					- [C] Paths
					- [C] Files

			- 字节操作
按操作对象分为文件、管道、数组、基本数据类型、对象序列化、缓冲操作、字节字符流转化控制、打印控制

			  以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。

				- [C] InputStream字节读取

					- 节点流

					  直接与数据源相连，读入或读出。

						- [C] FileInputStream
介质流，从File本地文件中读取数据

						  /**  * 复制文件:一边读，一边写  */ 、class hello { public static void main(String[] args) throws IOException { if (args.length != 2) { System.out.println("命令行参数输入有误，请检查"); 
						  System.exit(1); 
						  }
						   File file1 = new File(args[0]); 
						  File file2 = new File(args[1]); 
						  if (!file1.exists()) {
						   System.out.println("被复制的文件不存在"); 
						  System.exit(1); 
						  } 
						  InputStream input = new FileInputStream(file1); 
						  OutputStream output = new FileOutputStream(file2); 
						  if ((input != null) && (output != null)) { int temp = 0;
						   while ((temp = input.read()) != (-1)) { output.write(temp);
						   } } 
						  input.close(); 
						  output.close(); 
						  } }

						- [C] PipedInputStream
是从与其它线程共用的管道中读取数据。PipedInputStream的一个实例要和PipedOutputStream的一个实例共同使用，共同完成管道的读取写入操作。主要用于线程操作。

						  /**  * 消息发送类  * */ 
						  class Send implements Runnable { private PipedOutputStream out = null; public Send() { out = new PipedOutputStream(); } public PipedOutputStream getOut() { return this.out; } public void run() { String message = "hello , Rollen"; try { out.write(message.getBytes()); } catch (Exception e) { e.printStackTrace(); } try { out.close(); } catch (Exception e) { e.printStackTrace(); } } }
						  
						  作者：小明
						  链接：https://zhuanlan.zhihu.com/p/28286559
						  来源：知乎
						  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
						  
						  /**  * 接受消息类  */ class Recive implements Runnable { private PipedInputStream input = null; public Recive() { this.input = new PipedInputStream(); } public PipedInputStream getInput() { return this.input; } public void run() { byte[] b = new byte[1000]; int len = 0; try { len = this.input.read(b); } catch (Exception e) { e.printStackTrace(); } try { input.close(); } catch (Exception e) { e.printStackTrace(); } System.out.println("接受的内容为 " + (new String(b, 0, len))); } } /**  * 测试类  */ class hello { public static void main(String[] args) throws IOException { Send send = new Send(); Recive recive = new Recive(); try { //管道连接 send.getOut().connect(recive.getInput()); } catch (Exception e) { e.printStackTrace(); } new Thread(send).start(); new Thread(recive).start(); } }

						- [C] ByteArrayInputStream
介质流，从Byte数组中读取数据

						  public static void main(String[] args) throws IOException { String str = "ROLLENHOLT"; ByteArrayInputStream input = new ByteArrayInputStream(str.getBytes()); ByteArrayOutputStream output = new ByteArrayOutputStream(); int temp = 0; while ((temp = input.read()) != -1) { char ch = (char) temp; output.write(Character.toLowerCase(ch)); } String outStr = output.toString(); input.close(); output.close(); System.out.println(outStr); }

					- 处理流，和节点流配合使用

					  与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。

						- [C] ObjectInputStream
装饰流（装饰模式），对象反序列化
						- [C] FilterInputStream

							- [C] BufferedInputStream

							  public static void main(String[] args) throws IOException { BufferedReader buf = new BufferedReader( new InputStreamReader(System.in)); String str = null; System.out.println("请输入内容"); try{ str = buf.readLine(); }catch(IOException e){ e.printStackTrace(); } System.out.println("你输入的内容是：" + str); }

							- [C] DataInputStream
直接读入一个8个字节的long类型或4个字节的float类型，无需把基本类型转换成字符串输出
							- [C] LineNumberInputStream
							- [C] PushbackInputStream

						- [C] SequenceInputStream
可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取
						- [C] StringBufferInputStream
介质流，从StringBuffer对象中读取数据

				- [C] OutputStream字节写出
和InputStream有对应关系

					- 节点流

					  直接与数据源相连，读入或读出。

						- [C] FileOutputStream
介质流，向File本地文件中写入数据
						- [C] PipedOutputStream
						- [C] ByteArrayOutputStream
介质流，向Byte数组中写入数据

					- 处理流，和节点流配合使用

					  与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。

						- [C] ObjectOutputStream
对象序列化，把封装的对象直接输出，而不是一个个在转换成字符串再输出
						- [C] FilterInputStream

							- [C] BufferedOutputStream
介质流，向StringBuffer中写入数据
							- [C] DataOutputStream
直接输出一个8个字节的long类型或4个字节的float类型，无需把基本类型转换成字符串输出
							- [C] printStream

							  public static void main(String[] args) throws IOException { File file = new File("/Users/liuluming/Documents/hello.txt"); // 此刻直接输出到屏幕 System.out.println("hello"); try { System.setOut(new PrintStream(new FileOutputStream(file))); } catch (FileNotFoundException e) { e.printStackTrace(); } System.out.println("这些内容在文件中才能看到哦！"); }

			- 字符操作

			  以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。

				- [C] Reader字符读取

					- 节点流

					  直接与数据源相连，读入或读出。

						- [C] CharArrayReader
						- [C] StringReader
						- [C] InputStreamReader

							- [C] FileReader

						- [C] PipedReader
						- [C] FilterReader

							- [C] PushbackReader

					- 处理流，和节点流配合使用

					  与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。

						- [C] BufferedReader 
带缓冲区的处理流，缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。

							- [C] LineNumberReader

						- 转换流

						  可对读取到的字节数据经过指定编码转换成字符

							- [C] InputStreamReader

							  String fileName= "d:"+File.separator+"hello.txt"; 
							  File file=new File(fileName); 
							  Writer out=new OutputStreamWriter(new FileOutputStream(file)); 
							  out.write("hello"); 
							  out.close();

				- [C] Writer字符写出
和Reader有对应关系

					- 节点流

					  直接与数据源相连，读入或读出。

						- [C] CharArrayWriter
						- [C] StringWriter
						- [C] PipedWriter

					- 处理流，和节点流配合使用

					  与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。

						- [C] BufferedWriter
						- 转换流

						  输出流转到写流；

							- [C] OutputStreamWriter

							  String fileName= "d:"+File.separator+"hello.txt"; File file=new File(fileName); Reader read=new InputStreamReader(new FileInputStream(file)); char[] b=new char[100]; int len=read.read(b); System.out.println(new String(b,0,len)); read.close();

								- [C] FileWriter

						- [C] printWriter

			- 对象操作

				- Serializable
序列化

			- 网络操作

				- Socket

		- [P] java.nio.*
（提供操作系统层面I/O操作的支持）

			- java.nio
			- I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。

面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。

面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。

I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。

		- [P] java.net.*
（提供网络编程的工具设施）

	- 开发商扩展包
javax.Extension Package

		- [P]  javax.servlet.*
服务器数据库中间层设施

	- 集成库
Integration Libraries

		- IDL

			- Java IDL（Interface Definition Language，接口定义语言）为 JavaTM 平台添加了 CORBA（Common Object Request Broker Architecture，公用对象请求代理体系结构）功能，从而可提供基于标准的互操作性和连接性。

		- JDBC

			- JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序

		- JNDI

			- JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。

		- RMI

			- RMI(Remote Method Invocation，远程方法调用)是用Java在JDK1.2中实现的，它大大增强了Java开发分布式应用的能力。Java作为一种风靡一时的网络开发语言，其巨大的威力就体现在它强大的开发分布式网络应用的能力上，而RMI就是开发百分之百纯Java的网络分布式应用系统的核心解决方案之一。其实它可以被看作是RPC的Java版本。但是传统RPC并不能很好地应用于分布式对象系统。而Java RMI 则支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。

		- RMI-IIOP

			- RMI以Java为核心，可与采用本机方法与现有系统相连接。IIOP，Internet Inter-ORB Protocol(互联网内部对象请求代理协议)，它是一个用于CORBA 2.0及兼容平台上的协议。

		- Scripting

			- 动态语言支持

## Java语言规范

## Java虚拟机规范
Java Virtual Machine (JVM)

java 虚拟机，当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理 / 垃圾回收和安全机制等。
注意区分JVM规范和虚拟机的具体实现，比如JVM对内存区域划分了方法区，而HotSpot虚拟机将方法区具体实现为永久区。

参考资料：
《深入理解JVM虚拟机》

### 内存自动管理机制
（主要讲存储器）

- Linux操作系统| JVM | Java应用程序的内存关系

	- 从Linux系统上看，Linux系统将硬件的内存划分成引导系统的BIN区，以及内核内存（Kernel space）和用户内存（User space）。

		- BIN区域
		- 内核内存是Linux自身使用的内存空间，主要提供给程序调度、内存分配、连接硬件资源等程序逻辑使用。
		- 用户内存是提供给各个进程主要空间，Linux给各个进程提供相同的虚拟内存空间；这使得进程之间相互独立，互不干扰。实现的方法是采用虚拟内存技术：给每一个进程一定虚拟内存空间，而只有当虚拟内存实 际被使用时，才分配物理内存。

	- JVM本质就是一个进程，因此其内存空间（也称之为运行时数据区，注意与JMM的区别）也有进程的一般特点。

		- JVM对内存的使用和一般进程不同。JVM向操作系统申请一整段内存区域（具体大小可以在JVM参数调节）作为Java程序的堆（分为新生代和老年代）；
当Java程序申请内存空间，比如执行new操作，JVM将在这段空间中按所需大小分配给Java程序，并且Java程序不负责通知JVM何时可以释放这 个对象的空间，垃圾对象内存空间的回收由JVM进行。
		- 优点：
JVM的内存管理方式的优点是显而易见的，包括：第一，减少系统调用的次数，JVM在给Java程序分配内存空间时不需要操作系统干预，仅仅在 Java堆大小变化时需要向操作系统申请内存或通知回收，而普通程序每次内存空间的分配回收都需要系统调用参与；第二，减少内存泄漏，普通程序没有（或者 没有及时）通知操作系统内存空间的释放是内存泄漏的重要原因之一，而由JVM统一管理，可以避免程序员带来的内存泄漏问题。

	- Java应用程序

		- 应用程序通常不直接和内核内存打交道，内核内存由操作系统进行管理和使用；不过随着Linux对性能的关注及改进，一些新的特性使得应用程序可以使用内核内存，或者是映射到内核空间。Java NIO正是在这种背景下诞生的，其充分利用了Linux系统的新特性，提升了Java程序的IO性能。通过Java NIO，Java程序可以越过JVM直接向系统申请内存。

- JVM内存区域与内存泄漏异常

	- 运行时数据区域
（JVM作为一个线程所占的内存空间）

		- 线程隔离的数据区的构成
（这几种数据区对于每个线程来说是私有的）

			- 程序计数器 Program Counter Register

				- 作用：存放正在执行的字节码指令的地址（也就是字节码的行号）。字节码解释器依赖程序计数器中的数据来读取字节码指令，实际运行时的分支、循环、跳转、异常处理、线程恢复等都需要

					- Java方法：PC存放指令地址
native方法：PC存放undefined

			- 虚拟机栈 VM stack

				- 作用：
线程下的一个方法执行时
建立【栈帧】，存放对应这个方法的局部变量表、操作数栈、动态链接、方法出口

					- 局部变量表存放了方法的方法参数和局部变量。
他们可能的数据类型有两种，编译器可知的数据（int、byte等基本数据类型）和对象引用（reference类型，指向堆中对象实例存放的直接地址或者句柄（其中有字段数据），或者指向方法区中的类型信息（类文件加载进来的类型信息，运行期加入的常量池的内容））
					- 操作数栈(也可以称之为表达式栈（Expression Stack))在执行字节码指令的时候使用，它和通用寄存器在 native CPU 中使用的方式类似。大多数 JVM 字节码通过 pushing，popping，duplicating，swapping，或生产消费值的操作使用操作数栈。
					- 具体见虚拟机执行引擎部分内容

				- 异常：
线程请求栈深度大于虚拟机栈允许的大小（即每个线程可被分配的大小）：StackoverflowError
虚拟机栈动态扩展时无法申请到足够内存：OutOfMemoryError

					- 如果程序线程数很大，超出正常数范围（1000~2000），可以考虑减少每个线程允许分配的内存来容纳更多线程，满足虚拟机栈动态扩展的要求。

			- 本地方法栈 Native Method Stack

				- 什么是“本地方法”？
				- 整体作用机制和虚拟机栈基本相同

		- 所有线程共享的数据区的构成
（也是GC管理的数据区）

			- 堆 Heap

				- 作用：存放对象实例，包括一个对象应该有的实例变量、方法的参数和局部变量等等。
				- 构成：
可分为老年代和新生代（+永久代，即方法区）
新生代还可分为Eden | From Surviors | To Surviors
新生代和老年代可独立划分出线程私有的分配缓存区（TLAB， Thread Local Alloc Buffer）

					- TLAB:
TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，均摊对GC堆（eden区）里共享的分配指针做更新而带来的同步开销。

				- 异常：
没有足够的内存分配给实例时：OutOfMemoryError
				- 对象的创建、内存分配、初始化和访问
堆Heap

					- 创建，通过常量池中类的符号引用来执行类的加载检查。若类已加载/解析/初始化，可直接创建对象，否则加载类
					- 内存分配，依据垃圾收集器是否具有压缩整理功能（compact）决定
如果有，那么内存是规整的，使用指针碰撞（bump the pointer)来画出内存区域。
如果没有，那么内存不规整，使用空闲列表(Free List)来画出空闲区域
同时，多线程情况下，预先为每个线程分配TLAB来保证每次内存分配的原子性。

						- 每一个对象在内存区域中包括3部分信息：
1）Object Header：
    partA:Mark Word，存储对象自身的运行时数据，如哈希码（HashCode）、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等
    partB:类型指针，指向存储类型元数据，用来确定对象是归属于哪个类的实例
2）Instance Data：【存储有效信息】，包括【各数据类型的字段内容】（不包括常量字段、静态域字段，这些存在方法区），按虚拟机规定的分配策略（FieldsAllocationStyle）有序存放
3）Padding：内存对齐

					- 初始化，为初始分配的内存置零。并添加对象头Object Header信息

						- 代码会另行执行另一部分初始化工作，为内存区域赋值

					- 访问

						- java栈（VM Stack/ Native Method Stack）中的本地/局部变量表，存有reference数据，采用直接地址或句柄的方法，指向对象。两种方法各有优劣，直接地址访问快，但reference要频繁更新，句柄则反之。

			- 方法区 Method area
（实际上，GC管理得比较少，原因是效率低，难度高。GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。 ）

				- 作用：存放已被 加载的类的信息、 常量、 静态变量（类变量)、 即时编译器编译后的代码等数据

					- 类型信息的补充说明：具体看类的文件结构部分。
（可以简单看作两部分，描述信息和常量池）
描述信息：版本、 继承关系（父类、接口等）、字段、 方法、 属性等描述信息
常量池constant pool table：编译期生成的各种字面量和符号引用

				- 构成：

					- 运行时常量池
（区别于类文件结构中的常量池）

						- 作用：存放类的常量池信息，包括编译器生成的和运行期动态加入的。
						- 异常：
OutOfMemoryError

							- 举例：
string.intern()

					- 其他部分结构

						- 存放其他部分，即描述信息
这其中有.class类文件中方法表Code属性的内容

				- 异常：
同Heap和Stack一样，没有足够内存用以分配时：OutOfMemoryError异常

					- 使用Spring等框架时，动态生成大量的类，要求方法区有足够的空间来存储，则可能导致这种异常

	- 直接内存
Direct Memory

		- 到底什么是直接内存？

			- 就是JVM申请占用管理的内存以外的部分。
			- 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，这部分内存不是由jvm管理和回收的。需要手动的回收。

		- 直接内存和JVM运行时数据区域差别

			- 本机直接内存的分配不会受到JVM堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。 

		- 采用直接内存的优点：
    1：对于频繁的io操作，我们需要不断把内存中的对象复制到直接内存。然后由操作系统直接写入磁盘或者读出磁盘。这时候用到直接内存就减少了堆的内外内存来回复制的操作。
    2：我们在运行程序的过程中可能需要新建大量对象，对于一些声明周期比较短的对象，可以采用对象池的方式。但是对于一些生命周期较长的对象来说，不需要频繁调用gc，为了节省gc的开销，直接内存是必备之选。
    3：扩大程序运行的内存，由于jvm申请的内存有限，这时候可以通过堆外内存来扩大内存。
		- 异常：
动态扩展时可能出现OutOfMemoryError

- JVM垃圾收集器与内存分配策略
（主要考虑堆中内存（划分为新生代和老年代），少量考虑方法区（永久代））

	- 垃圾回收策略

		- 如何确定回收对象

			- 算法

				- 引用计数法

					- 算法：
给每个对象添加引用计数器，计数器为0的对象可清理
					- 缺点：
需要维护引用计数器，且占内存。
无法识别循环引用的情况。

				- 可达性分析算法

					- 算法：
找到GC roots节点，根据引用遍历，如果某些对象没有引用链reference chain可达到，可清理

						- GC roots：
两种栈引用的对象
方法区中类静态属性和静态变量引用的对象
						- 不同类型的引用：
强引用 不会GC
软引用 在空间不足可能内存溢出时会被GC
弱引用 再存活一次GC周期
虚引用 无关紧要，提供了被GC时发送通知的功能

			- 垃圾回收的数据区域

				- 主要是堆Heap
				- 方法区为什么不执行GC

					- 对于常量池的常量、接口，比较容易判别是否废弃
当是类是否废弃很难判断，需要判断类加载器、类的所有实例和实例的所有引用都已经被回收，才可以回收类。

		- 垃圾回收
总体采用分代收集的策略，新生代和老年代采用不同的垃圾收集器
同时，一切设计也要考虑到多线程

			- 垃圾回收算法：

				- 复制算法
（针对新生代数据保留比例小的特点）

					- 算法：
新生代分为一个Eden，两个Survival空间，默认比例是8:1。回收时，将Eden和一个Survival的存活对象全部放入到另一个Survival空间中，最后清理掉刚刚的Eden和Survival空间
当Survival空间不够时，由老年代进行内存分配担保
					- 不足：
虽然规避了标记-清除算法的缺点，但to Survival处于浪费的状态。如果对象存活率搞，复制工作就很大。

				- 标记-清除算法mark-sweep
（老年代使用）

					- 算法：
先标记出所有要回收的对象，在标记完成后统一进行对象的回收。
					- 不足：
1 是效率问题，标记和清除的效率都不高。
2 是空间问题，会产生大量不连续的内存碎片，碎片太多会都导致大对象无法找到足够的内存，从提前触发垃圾回收。

				- 标记-整理算法mark-compact
（老年代使用）

					- 算法：
根据老年代对象的特点，先标记存活对象，将存活对象移动到一端，然后直接清理掉端边界以外的对象

			- 垃圾回收算法实现
HotSpot虚拟机

				- 枚举根节点

					- 线程问题带来了停顿！！！
					- 可达性分析算法

				- 安全点

					-     HotSpot没有为每个指令都生成OopMap，只在特定的位置记录这些信息，这些位置称为安全点。安全点的选定不能太少，也不能太频繁，安全点的选定以“是否让程序长时间执行”为标准
					-     采用主动式中断的方式让所有线程都跑到最近的安全点上停顿下来。设置一个标志，各个程序执行的时候轮询这个标志，发现中断标志为真时自己就中断挂起

			- 垃圾收集器：

				- 分类

					- 1）串行GC

						- 在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定

					- 3）并行GC

						- 与旧生代的并发GC配合使用，多线程的

					- 2）并行回收GC

						- 在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数

				- 设计使用

					- 新生代

						- Serial 收集器
关注缩短停顿时间，适用前台

							- 运行机制
单线程回收
							- 优缺点：
简单而高效，对于运行在Client模式下的虚拟机来说是一个很好的选择（比如用户的桌面应用）
							- 和CMS配合

						- ParNew收集器
关注缩短停顿时间，适用前台

							- 运行机制
多线程并发的Serial

								- 并发可能是单个CPU体现，或者多个CPU

							- 优缺点
在单CPU的环境中，效果不如Serial好，随着CPU的增加，对于GC时系统资源的利用还是很有效的。
							- 和CMS配合

						- Parallel Scavenge收集器
关注吞吐量，适用在后台

							- 运行机制
并行的多线程收集器

								- 多CPU

							- 优缺点
同ParNew类似

					- 老年代

						- Serial old 收集器
关注缩短停顿时间，适用前台
						- Palallel Old 收集器
关注吞吐量，适用在后台
						- CMS (Concurrent Mark Sweep)
尤其关注缩短停顿，提高响应速度

							- 运行机制
分为四个步骤进行垃圾回收：初始标记，并发标记，重新标记，并发清除。只有初始标记和重新标记需要停顿。
初始标记只是标记一下GC Roots能直接关联到的对象，速度很快。并发标记就是进行GC Roots的Tracing。
重新标记为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记阶段稍长，远比并发时间短。
耗时最长的并发标记和并发清除过程中，处理器可以与用户线程一起工作。
							- 优缺点
1、垃圾回收时会占用一部分线程，导致系统变慢，总吞吐量会降低。
2、无法处理浮动垃圾，需要预留足够的内存空间给用户线程使用，可以通过X:CMSInitiatingOccupancyFraction 参数控制触发垃圾回收的阈值。如果预留的内存无法满足程序需要，就会出现“Concurrent Mode Failure”失败，这时将启动应急预案，启用Serial Old 进行垃圾回收，停顿时间变长。所以-XX:CMSInitiatingOccupancyFraction 参数的值设置的太高，会导致频繁“Concurrent Mode Failure”失败，性能反而降低。
3、标记-清理，容易产生内存碎片。-XX:+UseCMSCompactAtFullColletion 开启碎片整理功能，默认开启，-XX:CMSFullGCsBeforeCompaction，控制多少次不压缩的FullGC之后来一次带压缩的

					- 新生代和老年代

						- GI

							- 运行机制
    包括新生代和老年代的垃圾回收。和其他收集器相比的优点：并行和并发，分代收集，标记-整理，可预测的停顿。垃圾回收分为以下几个步骤：
    初始标记：标记GC Roots能够直接关联到的对象，这阶段需要停顿线程，时间很短
    并发标记：进行可达性分析，这阶段耗时较长，可与用户程序并发执行
    最终标记：修正发生变化的记录，需要停顿线程，但是可并行执行
    筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来执行回收计划
							- 优缺点

					- 永久代：某些版本的虚拟机中，永久代就是方法区

	- 内存分配策略

		-     对象优先在Eden分配，当新生区没有足够的内存是，通过分配担保机制提前转移到老年代中去
		-     大对象直接进入老年代。大对象是指需要大量连续内存空间的对象，虚拟机提供了参数 -XX:PretenureSizeThreshold（只对Serial，PerNew两个回收器起效），令大于这个值得对象直接在老年代分配，避免了Eden和两个Survival之间发生大量的内存复制。
		-     长期存活的对象将进入老年代。虚拟机给每个对象定义了对象年龄计数器（Age），如果对象在Eden出生，经过第一次Minor GC后依然存活，并且能被Survival容纳的话，将被移动到Survival，对象年龄设为1。对象在Survival中每熬过一次Major GC，年龄就增加1，达到一定程度（默认是15），就会被晋升到老年代。对象晋升老年代的阈值，可以通过参数-XX:MaxTenuringThreShold 指定
		-     动态对象年龄判断。如果在Survival空间中相同年龄所有对象的大小综合超过了Survival空间的一半，年龄大于等于这个年龄的对象都会被晋升到老年代。无需等待年龄超过MaxTenuringThreShold指定的年龄
		-     空间分配担保。只要老年代的连续空间大于新生代对象总和或者历次晋升的平均大小，就进行Major GC，否则进行Full  GC。

	- GC分析 性能调优

		- Minor GC、Major GC和Full GC之间的区别

    每次 Minor GC 会清理年轻代的内存
    Major GC 是清理老年代，Full GC 是清理整个堆空间—包括年轻代和老年代。大部分时候Major GC和Full GC区分的不是很明显
    不仅仅Major GC和Full GC会stop-the-world。所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。
		- 堆大小调优

			- 堆增大，GC间隔时间长，GC耗时长，垃圾较多。

				- 32位系统限制了堆的最大值，单个进程最大可用内存2G

			- 每次调整堆的大小，都触发Full GC

		- 新生代调优

			- 首先优先对新生代调优
			- 内存分配

				- Eden增大，增大Minor GC间隔，且Minor GC耗时变化不大（垃圾多）

			- 晋升promotion

				- 增大晋升的阈值，对象存在于survival中，可以降低Full GC的频率。但也可能增加对象在survival间不必要的重复拷贝
				- 总体上 多复制，少晋升

		- 老年代调优

			- 内存分配

				- 太大，GC耗时长，太小，GC频率高

			- 硬件优化

				- 加CPU

			- 程序代码优化

				- 减少不必要的缓存设计，减少老年代中的无用对象

			- 手动

				- 对于容易产生碎片的垃圾收集器，比如CMS，可以在不紧要时期手动开始Full GC

- 虚拟机性能监控与故障处理工具

### 虚拟机执行子系统

- Java实现平台无关性的基石
（平台无关性：不依赖具体的操作系统和机器指令集）

	- 字节码存储格式 .class：
将. java 或者其他语言编写成的程序文件 编译成 .class 二进制文件格式，包含有Java虚拟机指令集和符号表以及若干其他辅助信息。
字节码命令所能提供的语义描述能力比Java语言本身更加强大。
	- Java虚拟机：
虚拟机要求在.Class文件中使用许多【结构化约束】和【强制性的语法】，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。 

- 类文件结构

	- .Class 类文件结构

		- .Class 类文件结构的概述

			- 任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）
			- Class文件是一组以8位字节为基础单位的二进制流。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前[1]的方式分割成若干个8位字节进行存储。
1、紧凑。各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。
2、严格。文件中数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering,Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的。
3、只有两种数据类型。无符号数和表。

				- 无符号数属于基本的数据类型，以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个字节的无符号数，无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串值。
				- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地
以“_info”结尾。 表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张
表

		- .Class 类文件的各部分结构
（有序且紧凑）

			- 信息确认

				- 名称：魔数 Magic Number
类型：u4
数量：1

					- 功能：
每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件
是否为一个能被虚拟机接受的Class文件。

				- 名称：次版本号 Minor Version
类型：u2
数量：1

					- 功能：
次版本号

				- 名称：主版本号 Major Version
类型：u2
数量：1

					- 功能：
主版本号

			- 数据资源仓库

				- 名称：常量池容量计数值 constant_pool_count
类型：u2
数量：1

					- 功能：
表明常量的数量，从1开始计数。其他地方引用常量池中的数据时，索引值0表示不引用。

				- 名称：常量池 constant_pool
类型：cp_info
数量：1

					- 功能：
存放常量。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、 翻译到具体的内存地址之中。
（虚拟机加载Class文件的时候进行动态连接，Class文件中不会保存各个方法、 字段的最终内存布局信息，因此字段、 方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。 ） 
					- 常量有哪些？

						- 字面量 literal，比如文本字符串、声明为final的变量
						- 符号引用 Symbolic Reference

							- 分类

								- 类和接口 class| interface 的全限定名 Full Qualified Name

									- “org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一
个“；”表示全限定名结束。 

								- 字段 field 的简单名称和描述符 Descriptor

									- 简单名称是指没有类型和参数修饰的方法或者字段名称，比如类中的inc（）方法和m字段的简单名称分别是“inc”和“m”。

								- 方法 method 的简单名称和描述符 Descriptor

									- 描述符的作用是用来描述字段的数据类型、 方法的参数列表（包括数量、 类型以及顺序）和返回值。 根据描述符规则，基本数据类型（byte、 char、 double、 float、 int、 long、 short、 boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示

							- 用处：
除了描述代码中已有的名称和描述符，常量池的符号引用还被字段表（field_info）、 方法表（method_info）、 属性表（attribute_info）用来描述一些不方便使用“固定字节”进行表达的内容，比如方法的返回值是什么？有几个参数？每个参数的类型是什么？

					- 某类常量的存储结构

						- 标志位（u2）标明是什么类型的常量
						- 标志位后存储常量的各项信息，比如name_index、length、bytes等，每种常量的子项不一样。

			- 描述继承关系

				- 名称：访问标志 access_flags
类型：u2
数量：1

					- 功能：
一些类或者接口层次的访问信息，总共有16个位，目前用了8个位，每个位的1或0表示是否，比如：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；是否由用户代码生成；是否是一个注解；是否是一个枚举等。 

				- 名称：类索引 this_class
类型：u2
数量：1

					- 功能：
存储一个索引值，指向常量池中的常量，常量中存有本类的全限定名字符串、length等信息。

				- 名称：父类索引 super_class
类型：u2
数量：1

					- 功能：
存储一个索引值，指向常量池中的常量，常量中存有父类的全限定名字符串、length等信息。

				- 名称：接口计数器 interfaces_count
类型：u2
数量：1

					- 功能：
记录本类继承了几个接口

				- 名称：接口索引集合 interfaces
类型：u2
数量：1

					- 功能：
存储多个或不存储索引值，指向常量池中的常量，常量中存有接口的全限定名字符串、length等信息。

			- 类的实质内容

				- 名称：fields_count
类型：u2
数量：1

					- 功能：
记录后续有几个字段表

				- 名称：字段表集合 fields
类型：field_info
数量：1

					- 功能：
用于描述接口或者类中声明的变量。 字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。 
字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段
					- 结构：
每个字段表也是一个表，由多个无符号数和表组成。
对于字段表，结构组成有：

						- access flags

							- 功能：
存储字段修饰符，包括字段的作用域（public、 private、 protected修饰符）、 是实例变量还是类变量（static修饰符）、 可变性（final）、 并发可见性（volatile修饰符，是否强制从主内存读写）、 可否被序列化（transient修饰符），用0和1表示

						- name_index

							- 功能：
索引到常量池中的字段简单名称。

						- descriptor_index

							- 功能：
索引到常量池中的字段的描述符，包括字段数据类型（基本类型、 对象、 数组）等等

						- attribute_count
						- attributes

							- 功能：
为字段进一步提供属性说明，比如注明是否是运行时自动生成的
							- 常见属性举例

								- 属性名：
ConstantValue
功能：
说明这个字段是Final，这使得类加载的准备阶段给该字段赋值时就会给最终值，而不是0/null值。

				- 名称：methods_count
类型：u2
数量：1

					- 功能：
记录后续有几个方法表

				- 名称：方法表集合 methods
类型：method_info
数量：1

					- 功能：
与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。
（在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。 ）
					- 结构：
每个方法表也是一个表，由多个无符号数和表组成。
对于方法表，结构组成有：

						- access flags

							- 功能：
存储方法修饰符，包括方法的作用域（public、 private、 protected修饰符）、 是实例方法还是静态方法（static修饰符）、 因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。 与之相对的，synchronized、 native、 strictfp和abstract关键字可以修饰方法

						- name_index

							- 功能：
索引到常量池中的方法简单名称。

						- descriptor_index

							- 功能：
索引到常量池中的方法的参数列表和返回值，包括参数和返回值的数量、数据类型等等

						- attribute_count
						- attributes属性表集合

							- 功能：
大量方法本身的信息。重点区域。
							- 属性内容本身往下还可以进一步扩展包容其他属性
							- 常见属性举例

								- 属性名：
Code
功能：
方法体中Java代码编译成的字节码指令

									- 属性名：
LineNumberTable
功能：
Java源码的行号与字节码指令的对应关系 
									- 属性名：
 LocalVariableTable
功能：
方法的局部便狼描述 

								- 属性名：
Exceptions
功能：
方法可能抛出的异常 
								- 等等

				- 名称：attributes_count
类型：u2
数量：1

					- 功能：
记录后续有几个属性表集合

				- 名称：属性表 attributes
类型：attributes_info
数量：1

					- 功能：
在Class文件、 字段表、 方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息
					- 结构:
每种属性的存储结构都不一样，但是各自有固定的内容。
与Class文件中其他的数据项目要求严格的顺序、 长度和内容不同，属性表集合的限制稍
微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人
实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不
认识的属性。 为了能正确解析Class文件，《Java虚拟机规范（第2版）》 中预定义了9项虚拟机实现应当能识别的属性，而在最新的《Java虚拟机规范（Java SE 7）》 版中，预定义属性已经增加到21项

	- 字节码指令
（存在哪里？）

		- Java虚拟机的指令由一个字节长度的、 代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。 由于Java虚拟机采用面向操作数栈而不是寄存器的架构（这两种架构的区别和影响将在第8章中探讨），所以大多数的指令都不包含操作数，只有一个操作码。
		- 在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。由于指令长度限制为一个字节，指令集将会故意被设计成非完全独立的（Java虚拟机规范中把这种特性称为“Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。 
		- Java虚拟机部分指令集

			- 数据创建和访问

				- 加载和存储指令

					- 功能：
将数据在栈帧中的局部变量表和操作数栈之间来回传输

				- 对象创建与访问指令

					- 功能：
创建和访问对象实例和数组实例。还提供将数据在数组和操作数栈间传输的指令。
					- 区分：
JVM中对象实例和数组实例的创建指令是不同的

			- 算术和逻辑

				- 运算指令

					- 功能：
对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 
					- 区分：
分为对整型数据的运算指令和对浮点型数据的运算指令

				- 类型转换指令

					- 功能：
类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理 字节码指令集中数据类型相关指令无法与数据类型一一对应的问题，实现Not Orthogonal
					- 区分：
JVM支持隐式的宽化类型转换，但是数据类型缩窄必须为显式

			- 控制

				- 控制转移指令

					- 功能：
有条件或无条件地从指定的位置指令而不是控制转移指
令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。 比如ifeq、ret等等

				- 异常处理指令

					- 功能：
显示或自动地抛出异常。
					- 特点：
处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成的。

			- 过程

				- 操作数栈管理指令

					- 功能：
直接操作操作数栈，pop、push等

				- 方法调用和返回指令

					- 功能：
调用对象的实例方法，invoke系列、return系列等

		- 公有设计和私有实现

			- 公有设计：
Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。 这些内容与硬件、 操作系统及具体的Java虚拟机实现之间是完全独立的。具体的Java虚拟机实现只是必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。
			- 私有实现：
虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、 更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么。 虚拟机实现的方式主要有以下两种：
将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。
将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生
成技术）。

- 类文件的加载机制

	- 虚拟机把描述类的数据从【Class文件】加载到【内存】，并对数据进行校验、 转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

		- 程序运行期进行：
在Java语言里面，类型的加载、 连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 
		- 动态扩展：
用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。

	- 类 class 的生命周期

		- 整个生命周期包括：
加载（Loading）、 验证（Verification）、 准备（Preparation）、 解析（Resolution）、 初始化（Initialization）、 使用（Using）和卸载（Unloading）7个阶段。 其中验证、 准备、 解析3个部分统称为连接（Linking）
		- 各阶段的顺序关系：
加载、 验证、 准备、 初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。 

	- 类加载 Class loading
的时机

		- 主动引用（有且仅有）
（引用类，并立即对类进行初始化）

			- 1）遇到new、 getstatic、 putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、 读取或设置一个类的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
			- 2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
			- 3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
（对于接口来说，初始化一个接口时，不要求所有父接口也初始化，仅在使用时才会触发。其余方面和类一致）
			- 4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
			- 5）当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

		- 被动引用
（引用类，但没有触发初始化）

			- 除主动引用的5种情况之外，所有引用类的方式都
不会触发初始化，称为被动引用。 

	- 类加载器
java.lang.ClassLoader

		- 类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现。实现这个动作的代码模块称为“类加载器”。

			- 每一个类加载器，都拥有一个独立的类名称空间。
对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性

		- 分类

			- 启动类加载器（Bootstrap ClassLoader），这个类加载器使用JNI(Java Native Interface)实现，是虚拟机自身的一部分；

				- 主要加载< JAVA_HOME＞\lib

			- 扩展类加载器（Extension ClassLoader），继承自java.lang.ClassLoader

				- 主要加载＜JAVA_HOME＞\lib\ext

			- 应用程序类加载器（Application ClassLoader），继承自java.lang.ClassLoader
由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。

				- 加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

			- 自定义加载器

		- 类加载器的选择原则：
双亲委派模型

			- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。
			- 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

		- 破坏双亲委派模型

			- 比较晦涩，以后有机会再了解。

	- 类加载 Class loading
过程

		- 【1】加载阶段

			- 1）【通过一个类的全限定名来获取定义此类的二进制字节流】。可以通过控制类加载器来控制获取方式。
--可以从网络获取
--可以从ZIP包中获取
--可以在运行时动态生成，比如动态代理技术
在Java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流

				- 注意：
数组类和非数组类在加载上还是有所区分。数组类的元素如果不是对象引用，将由虚拟机自己生成，被标记为和引导类加载器相关联。否则数组类就与组件的类加载器相关联。

			- 2）将这个字节流所代表的静态存储结构转化为【方法区】的运行时数据结构。（存到运行时常量池）
方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。 

				- 说明：
方法区中存放了类的描述信息。
1）类的常量池信息，包括编译器生成的和运行期动态加入的。jvm为每个已加载的类型都维护一个常量池。
2）类的描述信息。

			- 3）在内存中生成一个代表这个类的【java.lang.Class对象】作为【方法区】这个类的各种数据的访问入口，为程序提供了访问【类型】信息的方法。。生成的位置依据虚拟机的具体实现而定。

				- Class对象存放位置：
HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面。一般来说是存放在堆Heap当中。
				- 类型信息是一个java类的描述信息(class mate),classloader加载一个类时从class文件中提取出来并存储在方法区。它包括以下信息：

1.类型的完整有效名，类型的修饰符(public,abstract, final的某个子集)，类型直接接口的一个有序列表及继承的父类。类型名称在java类文件和jvm中都以完整有效名出现。在java源代码中，完整有效名由类的所属包名称加一个”.”，再加上类名组成。例如，类Object的所属包为java.lang，那它的完整名称为java.lang.Object，但在类文件里，所有的”.”都被斜杠“/”代替，就成为java/lang/Object。完整有效名在方法区中的表示根据不同的实现而不同。

2.类型的常量池( constant pool)

3.域/字段(Field)信息

4.方法(Method)信息

5.除了常量外的所有静态(static)变量

6.classloader的引用

		- 连接阶段

			- 【2】验证阶段
大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、 字节码验证、 符号引用验证。

				- 可能抛出java.lang.VerifyError异常或其子类异常
				- 文件格式验证

					- 验证点：
是否以魔数开头
是否是当前虚拟机可处理的文件版本
常量池的常量中是否有不被支持的常量类型
指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
。。。

				- 元数据验证

					- 验证点：
这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
类中的字段、 方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。

				- 字节码验证
（最为复杂）
通过数据流和控制流分析，确定程序语义是合法的、 符合逻辑的。 

					- 验证点：
保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。
保证跳转指令不会跳转到方法体以外的字节码指令上。
保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、 完全不相干的一个数据类型，则是危险和不合法的

				- 符号引用验证
发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接解析阶段中发生。 符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验

					- 验证点：
符号引用中通过字符串描述的全限定名是否能找到对应的类。在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
符号引用中的类、 字段、 方法的访问性（private、 protected、 public、 default）是否可被当前类访问。

			- 【3】准备阶段（处理方法区的运行常量池内容）
正式为【类变量】分配内存并设置【类变量初始值】的阶段，这些变量所使用的内存都将在方法区中进行分配。 

				- 说明：
类变量也就是static静态变量，不包括实例变量。
类变量初始值一般为零值，也有Final限定符伴随的ConstantValue属性产生的例外情况

			- 【4】解析阶段（处理方法区中运行常量池的内容）
静态解析，将常量池内的符号引用（部分）替换为直接引用的过程。（另一部分在动态连接时替换）
解析动作主要针对类或接口、 字段、 类方法、 接口方法、 方法类型、 方法句柄和调用点限定符7类符号引用进行

				- 说明：
符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。 
直接引用（Direct References）：直接引用可以是直接指向目标的指针、 相对偏移量或是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果有了直接引用，那引用的目标必定已经在内存中存在。
				- 类或接口的解析：


		- 【5】初始化阶段（处理堆中的内容）
真正开始执行类中定义的Java程序代码（或者说是字节码），根据程序员通过程序制定的主观计划去初始化类变量和其他资源。

			- 程序代码初始化顺序：基类静态代码块，基类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——派生类静态代码块，派生类静态成员字段（并列优先级，按照代码中出现的先后顺序执行，且只有第一次加载时执行）——基类普通代码块，基类普通成员字段（并列优点级，按代码中出现先后顺序执行）——基类构造函数——派生类普通代码块，派生类普通成员字段（并列优点级，按代码中出现先后顺序执行）——派生类构造函数

- 字节码执行引擎

	- 在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。 在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

		- 虚拟机与物理机
“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、 硬件、 指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。
		- .Class文件是Java虚拟机执行引擎的数据入口

	- 运行时栈帧（存储在内存中的虚拟机栈）
是支持方法调用和方法执行的数据结构

		- 数据结构

			- 局部变量表

				- 存放传入方法的方法参数和方法内部定义的局部变量。 
他们可能的数据类型有两种，编译器可知的数据（int、byte等基本数据类型）和对象引用（reference类型，指向堆中对象实例存放的直接地址或者句柄（其中有字段数据），或者指向方法区中的类型信息（类文件加载进来的类型信息，运行期加入的常量池的内容））

			- 操作数栈
Operand Stack
后进先出LIFO

				- 操作数栈(也可以称之为表达式栈（Expression Stack))在执行字节码指令的时候使用，它和通用寄存器在 native CPU 中使用的方式类似。
大多数 JVM 字节码通过 pushing，popping，duplicating，swapping，或生产消费值的操作使用操作数栈。
严格要求字节码指令和栈中元素的数据类型要对应。

			- 栈帧信息

				- 指向运行时常量池（在方法区）中该栈帧所属方法的引用

					- 功能：
用于支持动态连接
					- 说明：静态解析和动态连接
Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。 这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。 另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 

				- 方法返回地址

					- 功能：
返回到上层的调用方法
					- 说明：方法的返回方式
第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。
另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。 一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。

				- 一些额外的附加信息

					- 例如与调试相关的信息

		- 容量：
栈帧中局部变量表、操作数栈的最大深度在编译字节码时期已经确定，并且写入到方法表的Code属性之中，不受运行期影响。所以总体上栈帧大小也已确定。
容量单位是32位为1 slot
		- 当前栈帧：
一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。 对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。 

	- 方法调用

		- 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
		- 调用方法

			- 解析调用 Resolution

				- 一定是静态的
				- 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。 换句话说，调用目标在程序代码写好、 编译器进行编译时就必须确定下来，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成

			- 分派调用 Dispatch
基于面向对象的封装、继承和多态产生

				- 静态分派
（多分派，根据静态类型和参数类型两个宗量决定调用的方法是哪个）

					- 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。 静态分派的典型应用是方法重载。由于方法支持重载，而只有运行期才能确定实际的对象类型，进而确定实际采用的方法。

				- 动态分派
（单分派，只根据动态运行时接收者的类型决定调用的方法是哪个）

					- 程序在运行期才能确定接收者的实际类型，把常量池中的对应的类方法符号引用解析到了不同的直接引用上
					- 优化：虚方法表的建立
由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。 面对这种情况，最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表（Vritual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Inteface Method Table，简称itable），使用虚
方法表索引来代替元数据查找以提高性能。 

						- 动态分派的具体实现可以看程序优化部分的内容

		- 动态语言的支持
java.lang.invoke包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制

	- 方法执行

		- 解释执行和编译执行
Java虚拟机可能采用其中一种
		- Java虚拟机——基于栈的指令集
物理机——基于寄存器的指令集

			- 基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。 
虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、 入栈操作本身就产生了相当多的指令数量。 更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。 

		- 基于栈的字节码执行引擎

			- 整个运算过程的中间变量都以操作数栈的出栈、 入栈为信息交换途径

### 程序编译与代码优化

- 编译期优化

	- 逃逸分析

	  逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。 甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。

- 运行期优化

### 高效并发
——虚拟机视角的并发编程
（具体请看并发编程部分）

- 内存模型与线程

	- 物理机的内存模型

		- 物理机内存模型的设计目标：
定义内存使用规则，协调并发问题和计算机性能利用问题

			- 并发问题常存在于服务器，衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second,TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。 对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。

		- 内存模型：主内存+高速缓存Cache
（为了协调IO操作和处理器计算速度的差异，硬件上引入了高速缓存）

			- 缓存一致性协议Cache Coherence
（为了协调多个处理器各自的高速缓存和主内存的一致性的问题，物理机对缓存和内存的访问遵循某种缓存一致性协议，比如MSI、 MESI（Illinois Protocol）、 MOSI、 Synapse、 Firefly及Dragon Protocol等）

		- 乱序执行优化Out-Of-Order Execution
处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致

	- Java虚拟机-线程内存模型
Java Memory Model,JMM

		- JMM的设计目标：
定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。（主要是线程共享区域——堆的变量。）
		- 内存模型：主内存+工作内存
（所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。 每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、 赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。）

			- JMM和Java内存区域的区别：
主内存、 工作内存与Java内存区域中的Java堆、 栈、 方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、 主内存、 工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存。
			- 主内存和工作内存的交互：
一系列相互关联的原子性指令

				- 原子性指令

					- lock--unlock
					- read-load-use
					- assign-store-write

				- long、double变量的非原子性协定：
对于原子性的指令，可以把64位操作分为两次32位操作。但目前商用虚拟机还是通过具体实现保证了原子性。

		- Java虚拟机的即时编译器中有类似乱序执行优化的指令重排序（Instruction Reorder）优化

			- 原因：
GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。 
			- volatile修饰符的语义：
保证可见性，volatile变量不会被缓存在寄存器中（只有拥有线程可见）或者其他对CPU不可见的地方，每次总是从主存中读取volatile变量的结果。但不保证变量的原子性。比如自加操作不是原子操作，使用volatile变量是不能保证线程同步的。

此外，在语义上还禁用了指令重排序。

				- 应用volatile变量的三个原则：
    （1）写入变量不依赖此变量的值，或者只有一个线程修改此变量
    （2）变量的状态不需要与其它变量共同参与不变约束
    （3）访问变量不需要加锁

		- 线程安全性问题

			- 线程安全性的内涵

				- 原子性Atomicity
单个线程执行一系列操作时是不可分割的
				- 可见性Visibility
可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 工作内存中的变量会即刻同步到主存。
				- 有序性Ordering
有序性（Ordering）：Java内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。 前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

			- Java存储模型中，JMM的先行发生原则
happen-before

				- 什么是先行发生原则

					- 先行发生是Java内存模型中定义的两项JMM操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、 发送了消息、 调用了方法等。 
JMM动作（Java Memeory Model Action），Java存储模型动作。
					- Java中天然的先行发生关系
无须同步器

						- 程序次序规则（Program Order Rule）：在一个线程内，程序操作按照控制流顺序发生。
						- 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。 这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
						- volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
						- 线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。
						- 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、 Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
						- 线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通Thread.interrupted（）方法检测到是否有中断发生。
						- 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。
						- 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

				- 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。

	- Java虚拟机的线程执行模型

		- Java虚拟机的线程实现
（和平台有关）

			- Java语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start（）且还未结束的java.lang.Thread类的实例就代表了一个线程。 
我们注意到Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。 在Java API中，一个Native方法往往意味着这个方法没有使用或无法使用
平台无关的手段来实现（当然也可能是为了执行效率而使用Native方法，不过，通常最高效率的手段也就是平台相关的手段）。 
			- 在目前的JDK版本中，线程模型为基于操作系统原生线程模型来实现。 因此，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。 线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是透明的。

				- Windows和Linux下，Java线程和操作系统线程是一对一的

		- Java虚拟机的线程调度

			- 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive ThreadsScheduling）。
			- Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。但物理机和虚拟机的优先级往往实现不一样，不能一一对应。且操作系统本身也存在可修改优先级的子程序，比如在Windows系统中存在一个称为“优先级推进器”（Priority Boosting，当然它可以被关闭掉）的功能。

		- Java虚拟机的线程状态

			- 状态

				- New
				- Running
				- Waitting
				- Blocked
				- Terminated

			- 转换

- 保证并发正确
实现线程安全

	- 理解：什么算是并发的正确性？
线程安全的代码都必须具备一个特征：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。 这点听起来简单，但其实并不容易做到，在大多数场景中，我们都会将这个定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”，这个定义的其他描述也能够成立的话，我们就可以称它是线程安全了。
	- 线程安全的程度：
线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、 绝对线程安全、 相对线程安全、 线程兼容和线程对立。

		- 线程对立：
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。 由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。

	- 线程安全的实现方法：
目标：实现【同步】

		- 互斥同步（Mutual Exclusion＆Synchronization）==阻塞同步
--当一个线程进入临界区后，其他线程必须等待
--属于悲观的并发策略

			- 互斥是实现同步的一种手段，临界区（Critical
Section）、 互斥量（Mutex）和信号量（Semaphore）、事件（Event）都是主要的互斥实现方式。
			- 实现方式

				- java原生的锁-内置锁-synchronized关键字：
如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。
				- JVM对synchronized关键字的锁优化：
克服了synchronized阻塞挂起性能消耗较大的问题。总体上使得synchronized性能和ReentrantLock性能接近

					- 自旋锁

						- 优化点：
互斥同步进入阻塞状态的开销都很大，应该尽量减少阻塞挂起的使用。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。
						- 使用场景：
自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。

在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。

					- 锁消除

						- 优化点：
锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。

锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。

						  对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：
						  
						  public static String concatString(String s1, String s2, String s3) {
						      return s1 + s2 + s3;
						  }
						  
						  String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：
						  
						  public static String concatString(String s1, String s2, String s3) {
						      StringBuffer sb = new StringBuffer();
						      sb.append(s1);
						      sb.append(s2);
						      sb.append(s3);
						      return sb.toString();
						  }
						  
						  每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。

					- 锁粗化

						- 优化点：
如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。

					- synchronize的monitor实现：
JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。

以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态。


						- 一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。
						- 重量级锁

							- 概念：

						- 轻量级锁
和锁膨胀

							- 概念：
							- 优化原理：
轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。
对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。
							- 实现原理：
当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。
如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。

						- 偏向锁

							- 概念：
							- 优化原理：
偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。
							- 实现原理：
当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

				- 使用java.util.concurrent（下文称J.U.C）包中的重入锁
（ReentrantLock）来实现同步：


		- 非阻塞同步
--允许多个线程同时进入临界区
--基于冲突检测的乐观的并发策略

			- 实现基础：
基于原子性的硬件指令集，才能有效实现

				- 测试并设置（Test-and-Set）
				- 获取并增加（Fetch-and-Increment）
				- 交换（Swap）
				- 比较并交换（Compare-and-Swap，简称CAS）
				- 加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）

			- 实现方式

				- 原子变量
（基于CAS实现）

					- CAS带来的ABA问题

						- J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

		- 无同步

			- 如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。
			- 实现方式

				- 栈封闭
				- 线程本地存储
				- 可重入代码

*XMind: ZEN - Trial Version*